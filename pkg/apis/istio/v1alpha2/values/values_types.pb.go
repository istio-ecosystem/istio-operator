// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: values_types.proto

package v1alpha2

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	io "io"
	v1 "k8s.io/api/core/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type LoadSheddingConfigMode int32

const (
	LoadSheddingConfig_DISABLED LoadSheddingConfigMode = 0
	LoadSheddingConfig_LOG_ONLY LoadSheddingConfigMode = 1
	LoadSheddingConfig_ENFORCE  LoadSheddingConfigMode = 2
)

var LoadSheddingConfigMode_name = map[int32]string{
	0: "DISABLED",
	1: "LOG_ONLY",
	2: "ENFORCE",
}

var LoadSheddingConfigMode_value = map[string]int32{
	"DISABLED": 0,
	"LOG_ONLY": 1,
	"ENFORCE":  2,
}

func (x LoadSheddingConfigMode) String() string {
	return proto.EnumName(LoadSheddingConfigMode_name, int32(x))
}

func (LoadSheddingConfigMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{21, 0}
}

// Specifies the sidecar's default behavior when handling outbound traffic from the application.
type OutboundTrafficPolicyConfigMode int32

const (
	//outbound traffic to unknown destinations will be allowed, in case there are no services or ServiceEntries for the destination port
	OutboundTrafficPolicyConfig_ALLOW_ANY OutboundTrafficPolicyConfigMode = 0
	//restrict outbound traffic to services defined in the service registry as well as those defined through ServiceEntries
	OutboundTrafficPolicyConfig_REGISTRY_ONLY OutboundTrafficPolicyConfigMode = 1
)

var OutboundTrafficPolicyConfigMode_name = map[int32]string{
	0: "ALLOW_ANY",
	1: "REGISTRY_ONLY",
}

var OutboundTrafficPolicyConfigMode_value = map[string]int32{
	"ALLOW_ANY":     0,
	"REGISTRY_ONLY": 1,
}

func (x OutboundTrafficPolicyConfigMode) String() string {
	return proto.EnumName(OutboundTrafficPolicyConfigMode_name, int32(x))
}

func (OutboundTrafficPolicyConfigMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{30, 0}
}

type PilotIngressConfigIngressControllerMode int32

const (
	//all Ingress resources without annotation or with istio annotation.
	PilotIngressConfig_DEFAULT PilotIngressConfigIngressControllerMode = 0
	//only with istio annotation.
	PilotIngressConfig_STRICT PilotIngressConfigIngressControllerMode = 1
	//no ingress or sync.
	PilotIngressConfig_OFF PilotIngressConfigIngressControllerMode = 2
)

var PilotIngressConfigIngressControllerMode_name = map[int32]string{
	0: "DEFAULT",
	1: "STRICT",
	2: "OFF",
}

var PilotIngressConfigIngressControllerMode_value = map[string]int32{
	"DEFAULT": 0,
	"STRICT":  1,
	"OFF":     2,
}

func (x PilotIngressConfigIngressControllerMode) String() string {
	return proto.EnumName(PilotIngressConfigIngressControllerMode_name, int32(x))
}

func (PilotIngressConfigIngressControllerMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{32, 0}
}

// Configure the access log for sidecar to JSON or TEXT
type ProxyConfigAccessLogEncoding int32

const (
	ProxyConfig_JSON ProxyConfigAccessLogEncoding = 0
	ProxyConfig_TEXT ProxyConfigAccessLogEncoding = 1
)

var ProxyConfigAccessLogEncoding_name = map[int32]string{
	0: "JSON",
	1: "TEXT",
}

var ProxyConfigAccessLogEncoding_value = map[string]int32{
	"JSON": 0,
	"TEXT": 1,
}

func (x ProxyConfigAccessLogEncoding) String() string {
	return proto.EnumName(ProxyConfigAccessLogEncoding_name, int32(x))
}

func (ProxyConfigAccessLogEncoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{41, 0}
}

type ProxyConfigAutoInject int32

const (
	ProxyConfig_ENABLED  ProxyConfigAutoInject = 0
	ProxyConfig_DISABLED ProxyConfigAutoInject = 1
)

var ProxyConfigAutoInject_name = map[int32]string{
	0: "ENABLED",
	1: "DISABLED",
}

var ProxyConfigAutoInject_value = map[string]int32{
	"ENABLED":  0,
	"DISABLED": 1,
}

func (x ProxyConfigAutoInject) String() string {
	return proto.EnumName(ProxyConfigAutoInject_name, int32(x))
}

func (ProxyConfigAutoInject) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{41, 1}
}

// Specifies which tracer to use.
type ProxyConfigTracer int32

const (
	ProxyConfig_ZIPKIN    ProxyConfigTracer = 0
	ProxyConfig_LIGHTSTEP ProxyConfigTracer = 1
	ProxyConfig_DATADOG   ProxyConfigTracer = 2
)

var ProxyConfigTracer_name = map[int32]string{
	0: "ZIPKIN",
	1: "LIGHTSTEP",
	2: "DATADOG",
}

var ProxyConfigTracer_value = map[string]int32{
	"ZIPKIN":    0,
	"LIGHTSTEP": 1,
	"DATADOG":   2,
}

func (x ProxyConfigTracer) String() string {
	return proto.EnumName(ProxyConfigTracer_name, int32(x))
}

func (ProxyConfigTracer) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{41, 2}
}

// AddonIngressConfig is described in istio.io documentation.
type AddonIngressConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Hosts                []string `protobuf:"bytes,2,rep,name=hosts,proto3" json:"hosts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddonIngressConfig) Reset()         { *m = AddonIngressConfig{} }
func (m *AddonIngressConfig) String() string { return proto.CompactTextString(m) }
func (*AddonIngressConfig) ProtoMessage()    {}
func (*AddonIngressConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{0}
}
func (m *AddonIngressConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddonIngressConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddonIngressConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddonIngressConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddonIngressConfig.Merge(m, src)
}
func (m *AddonIngressConfig) XXX_Size() int {
	return m.Size()
}
func (m *AddonIngressConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_AddonIngressConfig.DiscardUnknown(m)
}

var xxx_messageInfo_AddonIngressConfig proto.InternalMessageInfo

func (m *AddonIngressConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *AddonIngressConfig) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

// ArchConfig is described in istio.io documentation.
type ArchConfig struct {
	// Sets pod scheduling weight for amd64 arch
	Amd64 uint32 `protobuf:"varint,1,opt,name=amd64,proto3" json:"amd64,omitempty"`
	// Sets pod scheduling weight for ppc64le arch.
	Ppc64Le uint32 `protobuf:"varint,2,opt,name=ppc64le,proto3" json:"ppc64le,omitempty"`
	// Sets pod scheduling weight for s390x arch.
	S390X                uint32   `protobuf:"varint,3,opt,name=s390x,proto3" json:"s390x,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArchConfig) Reset()         { *m = ArchConfig{} }
func (m *ArchConfig) String() string { return proto.CompactTextString(m) }
func (*ArchConfig) ProtoMessage()    {}
func (*ArchConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{1}
}
func (m *ArchConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArchConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArchConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArchConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArchConfig.Merge(m, src)
}
func (m *ArchConfig) XXX_Size() int {
	return m.Size()
}
func (m *ArchConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ArchConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ArchConfig proto.InternalMessageInfo

func (m *ArchConfig) GetAmd64() uint32 {
	if m != nil {
		return m.Amd64
	}
	return 0
}

func (m *ArchConfig) GetPpc64Le() uint32 {
	if m != nil {
		return m.Ppc64Le
	}
	return 0
}

func (m *ArchConfig) GetS390X() uint32 {
	if m != nil {
		return m.S390X
	}
	return 0
}

// CNIConfig is described in istio.io documentation.
type CNIConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CNIConfig) Reset()         { *m = CNIConfig{} }
func (m *CNIConfig) String() string { return proto.CompactTextString(m) }
func (*CNIConfig) ProtoMessage()    {}
func (*CNIConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{2}
}
func (m *CNIConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNIConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNIConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNIConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNIConfig.Merge(m, src)
}
func (m *CNIConfig) XXX_Size() int {
	return m.Size()
}
func (m *CNIConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CNIConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CNIConfig proto.InternalMessageInfo

func (m *CNIConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// CPUTargetUtilizationConfig is described in istio.io documentation.
type CPUTargetUtilizationConfig struct {
	TargetAverageUtilization int32    `protobuf:"varint,1,opt,name=targetAverageUtilization,proto3" json:"targetAverageUtilization,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *CPUTargetUtilizationConfig) Reset()         { *m = CPUTargetUtilizationConfig{} }
func (m *CPUTargetUtilizationConfig) String() string { return proto.CompactTextString(m) }
func (*CPUTargetUtilizationConfig) ProtoMessage()    {}
func (*CPUTargetUtilizationConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{3}
}
func (m *CPUTargetUtilizationConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPUTargetUtilizationConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPUTargetUtilizationConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPUTargetUtilizationConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPUTargetUtilizationConfig.Merge(m, src)
}
func (m *CPUTargetUtilizationConfig) XXX_Size() int {
	return m.Size()
}
func (m *CPUTargetUtilizationConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CPUTargetUtilizationConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CPUTargetUtilizationConfig proto.InternalMessageInfo

func (m *CPUTargetUtilizationConfig) GetTargetAverageUtilization() int32 {
	if m != nil {
		return m.TargetAverageUtilization
	}
	return 0
}

// CertManagerConfig is described in istio.io documentation.
type CertManagerConfig struct {
	Enabled bool   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Hub     string `protobuf:"bytes,2,opt,name=hub,proto3" json:"hub,omitempty"`
	// 	NodeSelector map[string]interface{} `json:"nodeSelector"`
	Resources            *v1.ResourceRequirements `protobuf:"bytes,3,opt,name=resources,proto3" json:"resources,omitempty"`
	Tag                  string                   `protobuf:"bytes,4,opt,name=tag,proto3" json:"tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *CertManagerConfig) Reset()         { *m = CertManagerConfig{} }
func (m *CertManagerConfig) String() string { return proto.CompactTextString(m) }
func (*CertManagerConfig) ProtoMessage()    {}
func (*CertManagerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{4}
}
func (m *CertManagerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertManagerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertManagerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertManagerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertManagerConfig.Merge(m, src)
}
func (m *CertManagerConfig) XXX_Size() int {
	return m.Size()
}
func (m *CertManagerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CertManagerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CertManagerConfig proto.InternalMessageInfo

func (m *CertManagerConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *CertManagerConfig) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *CertManagerConfig) GetResources() *v1.ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *CertManagerConfig) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

// CoreDNSConfig is described in istio.io documentation.
type CoreDNSConfig struct {
	CoreDNSImage       string `protobuf:"bytes,1,opt,name=coreDNSImage,proto3" json:"coreDNSImage,omitempty"`
	CoreDNSPluginImage string `protobuf:"bytes,2,opt,name=coreDNSPluginImage,proto3" json:"coreDNSPluginImage,omitempty"`
	Enabled            bool   `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// 	NodeSelector       map[string]interface{} `json:"nodeSelector,omitempty"`
	ReplicaCount         uint32   `protobuf:"varint,4,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CoreDNSConfig) Reset()         { *m = CoreDNSConfig{} }
func (m *CoreDNSConfig) String() string { return proto.CompactTextString(m) }
func (*CoreDNSConfig) ProtoMessage()    {}
func (*CoreDNSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{5}
}
func (m *CoreDNSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoreDNSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoreDNSConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoreDNSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoreDNSConfig.Merge(m, src)
}
func (m *CoreDNSConfig) XXX_Size() int {
	return m.Size()
}
func (m *CoreDNSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CoreDNSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CoreDNSConfig proto.InternalMessageInfo

func (m *CoreDNSConfig) GetCoreDNSImage() string {
	if m != nil {
		return m.CoreDNSImage
	}
	return ""
}

func (m *CoreDNSConfig) GetCoreDNSPluginImage() string {
	if m != nil {
		return m.CoreDNSPluginImage
	}
	return ""
}

func (m *CoreDNSConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *CoreDNSConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

// DefaultPodDisruptionBudgetConfig is described in istio.io documentation.
type DefaultPodDisruptionBudgetConfig struct {
	// k8s PodDisruptionBudget settings.
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DefaultPodDisruptionBudgetConfig) Reset()         { *m = DefaultPodDisruptionBudgetConfig{} }
func (m *DefaultPodDisruptionBudgetConfig) String() string { return proto.CompactTextString(m) }
func (*DefaultPodDisruptionBudgetConfig) ProtoMessage()    {}
func (*DefaultPodDisruptionBudgetConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{6}
}
func (m *DefaultPodDisruptionBudgetConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultPodDisruptionBudgetConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefaultPodDisruptionBudgetConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefaultPodDisruptionBudgetConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultPodDisruptionBudgetConfig.Merge(m, src)
}
func (m *DefaultPodDisruptionBudgetConfig) XXX_Size() int {
	return m.Size()
}
func (m *DefaultPodDisruptionBudgetConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultPodDisruptionBudgetConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultPodDisruptionBudgetConfig proto.InternalMessageInfo

func (m *DefaultPodDisruptionBudgetConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// DefaultResourcesConfig is described in istio.io documentation.
type DefaultResourcesConfig struct {
	// k8s resources settings.
	Requests             *ResourcesRequestsConfig `protobuf:"bytes,1,opt,name=requests,proto3" json:"requests,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *DefaultResourcesConfig) Reset()         { *m = DefaultResourcesConfig{} }
func (m *DefaultResourcesConfig) String() string { return proto.CompactTextString(m) }
func (*DefaultResourcesConfig) ProtoMessage()    {}
func (*DefaultResourcesConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{7}
}
func (m *DefaultResourcesConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultResourcesConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefaultResourcesConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefaultResourcesConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultResourcesConfig.Merge(m, src)
}
func (m *DefaultResourcesConfig) XXX_Size() int {
	return m.Size()
}
func (m *DefaultResourcesConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultResourcesConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultResourcesConfig proto.InternalMessageInfo

func (m *DefaultResourcesConfig) GetRequests() *ResourcesRequestsConfig {
	if m != nil {
		return m.Requests
	}
	return nil
}

// EgressGatewayConfig is described in istio.io documentation.
type EgressGatewayConfig struct {
	AutoscaleEnabled bool                        `protobuf:"varint,1,opt,name=autoscaleEnabled,proto3" json:"autoscaleEnabled,omitempty"`
	AutoscaleMax     uint32                      `protobuf:"varint,2,opt,name=autoscaleMax,proto3" json:"autoscaleMax,omitempty"`
	AutoscaleMin     uint32                      `protobuf:"varint,3,opt,name=autoscaleMin,proto3" json:"autoscaleMin,omitempty"`
	ConnectTimeout   string                      `protobuf:"bytes,4,opt,name=connectTimeout,proto3" json:"connectTimeout,omitempty"`
	Cpu              *CPUTargetUtilizationConfig `protobuf:"bytes,5,opt,name=cpu,proto3" json:"cpu,omitempty"`
	DrainDuration    *duration.Duration          `protobuf:"bytes,6,opt,name=drainDuration,proto3" json:"drainDuration,omitempty"`
	Enabled          bool                        `protobuf:"varint,7,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Env              map[string]string           `protobuf:"bytes,8,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Labels           *GatewayLabelsConfig        `protobuf:"bytes,9,opt,name=labels,proto3" json:"labels,omitempty"`
	NodeSelector     map[string]string           `protobuf:"bytes,10,rep,name=nodeSelector,proto3" json:"nodeSelector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 	PodAnnotations                   map[string]interface{}      `json:"podAnnotations,omitempty"`
	// 	PodAntiAffinityLabelSelector     []map[string]interface{}    `json:"podAntiAffinityLabelSelector"`
	// 	PodAntiAffinityTermLabelSelector []map[string]interface{}    `json:"podAntiAffinityTermLabelSelector"`
	Ports         []*PortsConfig           `protobuf:"bytes,11,rep,name=ports,proto3" json:"ports,omitempty"`
	Resources     *v1.ResourceRequirements `protobuf:"bytes,12,opt,name=resources,proto3" json:"resources,omitempty"`
	SecretVolumes []*SecretVolume          `protobuf:"bytes,13,rep,name=secretVolumes,proto3" json:"secretVolumes,omitempty"`
	// 	ServiceAnnotations               map[string]interface{}      `json:"serviceAnnotations,omitempty"`
	//    Type                             corev1.ServiceType          `json:"type,omitempty"`
	Zvpn                 *ZeroVPNConfig `protobuf:"bytes,14,opt,name=zvpn,proto3" json:"zvpn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EgressGatewayConfig) Reset()         { *m = EgressGatewayConfig{} }
func (m *EgressGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*EgressGatewayConfig) ProtoMessage()    {}
func (*EgressGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{8}
}
func (m *EgressGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressGatewayConfig.Merge(m, src)
}
func (m *EgressGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *EgressGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_EgressGatewayConfig proto.InternalMessageInfo

func (m *EgressGatewayConfig) GetAutoscaleEnabled() bool {
	if m != nil {
		return m.AutoscaleEnabled
	}
	return false
}

func (m *EgressGatewayConfig) GetAutoscaleMax() uint32 {
	if m != nil {
		return m.AutoscaleMax
	}
	return 0
}

func (m *EgressGatewayConfig) GetAutoscaleMin() uint32 {
	if m != nil {
		return m.AutoscaleMin
	}
	return 0
}

func (m *EgressGatewayConfig) GetConnectTimeout() string {
	if m != nil {
		return m.ConnectTimeout
	}
	return ""
}

func (m *EgressGatewayConfig) GetCpu() *CPUTargetUtilizationConfig {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *EgressGatewayConfig) GetDrainDuration() *duration.Duration {
	if m != nil {
		return m.DrainDuration
	}
	return nil
}

func (m *EgressGatewayConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *EgressGatewayConfig) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *EgressGatewayConfig) GetLabels() *GatewayLabelsConfig {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *EgressGatewayConfig) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *EgressGatewayConfig) GetPorts() []*PortsConfig {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *EgressGatewayConfig) GetResources() *v1.ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *EgressGatewayConfig) GetSecretVolumes() []*SecretVolume {
	if m != nil {
		return m.SecretVolumes
	}
	return nil
}

func (m *EgressGatewayConfig) GetZvpn() *ZeroVPNConfig {
	if m != nil {
		return m.Zvpn
	}
	return nil
}

// EnvoyMetricsConfig is described in istio.io documentation.
type EnvoyMetricsConfig struct {
	// Enables the Envoy Metrics Service.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Sets the destination Envoy Metrics Service address in Envoy.
	Host string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	// Sets the destination Envoy Metrics Service port in Envoy.
	Port                 int32    `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyMetricsConfig) Reset()         { *m = EnvoyMetricsConfig{} }
func (m *EnvoyMetricsConfig) String() string { return proto.CompactTextString(m) }
func (*EnvoyMetricsConfig) ProtoMessage()    {}
func (*EnvoyMetricsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{9}
}
func (m *EnvoyMetricsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyMetricsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyMetricsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyMetricsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyMetricsConfig.Merge(m, src)
}
func (m *EnvoyMetricsConfig) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyMetricsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyMetricsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyMetricsConfig proto.InternalMessageInfo

func (m *EnvoyMetricsConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *EnvoyMetricsConfig) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *EnvoyMetricsConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// GalleyConfig is described in istio.io documentation.
type GalleyConfig struct {
	Enabled bool              `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Image   string            `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	Mesh    map[string]string `protobuf:"bytes,3,rep,name=mesh,proto3" json:"mesh,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 	PodAntiAffinityLabelSelector     []map[string]interface{} `json:"podAntiAffinityLabelSelector"`
	// 	PodAntiAffinityTermLabelSelector []map[string]interface{} `json:"podAntiAffinityTermLabelSelector"`
	ReplicaCount         uint32                   `protobuf:"varint,4,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	Resources            *v1.ResourceRequirements `protobuf:"bytes,5,opt,name=resources,proto3" json:"resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GalleyConfig) Reset()         { *m = GalleyConfig{} }
func (m *GalleyConfig) String() string { return proto.CompactTextString(m) }
func (*GalleyConfig) ProtoMessage()    {}
func (*GalleyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{10}
}
func (m *GalleyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GalleyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GalleyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GalleyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GalleyConfig.Merge(m, src)
}
func (m *GalleyConfig) XXX_Size() int {
	return m.Size()
}
func (m *GalleyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GalleyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GalleyConfig proto.InternalMessageInfo

func (m *GalleyConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *GalleyConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *GalleyConfig) GetMesh() map[string]string {
	if m != nil {
		return m.Mesh
	}
	return nil
}

func (m *GalleyConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *GalleyConfig) GetResources() *v1.ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

// GatewayLabelsConfig is described in istio.io documentation.
type GatewayLabelsConfig struct {
	App                  string   `protobuf:"bytes,1,opt,name=app,proto3" json:"app,omitempty"`
	Istio                string   `protobuf:"bytes,2,opt,name=istio,proto3" json:"istio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GatewayLabelsConfig) Reset()         { *m = GatewayLabelsConfig{} }
func (m *GatewayLabelsConfig) String() string { return proto.CompactTextString(m) }
func (*GatewayLabelsConfig) ProtoMessage()    {}
func (*GatewayLabelsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{11}
}
func (m *GatewayLabelsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayLabelsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayLabelsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayLabelsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayLabelsConfig.Merge(m, src)
}
func (m *GatewayLabelsConfig) XXX_Size() int {
	return m.Size()
}
func (m *GatewayLabelsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayLabelsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayLabelsConfig proto.InternalMessageInfo

func (m *GatewayLabelsConfig) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *GatewayLabelsConfig) GetIstio() string {
	if m != nil {
		return m.Istio
	}
	return ""
}

// GatewaysConfig is described in istio.io documentation.
type GatewaysConfig struct {
	IstioEgressgateway   *EgressGatewayConfig  `protobuf:"bytes,1,opt,name=istio_egressgateway,json=istioEgressgateway,proto3" json:"istio_egressgateway,omitempty"`
	Enabled              bool                  `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	IstioIlbgateway      *ILBGatewayConfig     `protobuf:"bytes,3,opt,name=istio_ilbgateway,json=istioIlbgateway,proto3" json:"istio_ilbgateway,omitempty"`
	IstioIngressgateway  *IngressGatewayConfig `protobuf:"bytes,4,opt,name=istio_ingressgateway,json=istioIngressgateway,proto3" json:"istio_ingressgateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *GatewaysConfig) Reset()         { *m = GatewaysConfig{} }
func (m *GatewaysConfig) String() string { return proto.CompactTextString(m) }
func (*GatewaysConfig) ProtoMessage()    {}
func (*GatewaysConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{12}
}
func (m *GatewaysConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewaysConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewaysConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewaysConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewaysConfig.Merge(m, src)
}
func (m *GatewaysConfig) XXX_Size() int {
	return m.Size()
}
func (m *GatewaysConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewaysConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GatewaysConfig proto.InternalMessageInfo

func (m *GatewaysConfig) GetIstioEgressgateway() *EgressGatewayConfig {
	if m != nil {
		return m.IstioEgressgateway
	}
	return nil
}

func (m *GatewaysConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *GatewaysConfig) GetIstioIlbgateway() *ILBGatewayConfig {
	if m != nil {
		return m.IstioIlbgateway
	}
	return nil
}

func (m *GatewaysConfig) GetIstioIngressgateway() *IngressGatewayConfig {
	if m != nil {
		return m.IstioIngressgateway
	}
	return nil
}

type GlobalConfig struct {
	Arch *ArchConfig `protobuf:"bytes,30,opt,name=arch,proto3" json:"arch,omitempty"`
	// Configuration validation component namespace
	ConfigNamespace string `protobuf:"bytes,1,opt,name=configNamespace,proto3" json:"configNamespace,omitempty"`
	// Enables server-side validation of configuration.
	ConfigValidation bool `protobuf:"varint,2,opt,name=configValidation,proto3" json:"configValidation,omitempty"`
	// Enables MTLS for control plane.
	ControlPlaneSecurityEnabled bool `protobuf:"varint,3,opt,name=controlPlaneSecurityEnabled,proto3" json:"controlPlaneSecurityEnabled,omitempty"`
	// K8s NodeSelector
	DefaultNodeSelector map[string]string `protobuf:"bytes,31,rep,name=defaultNodeSelector,proto3" json:"defaultNodeSelector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// k8s PodDisruptionBudget settings.
	DefaultPodDisruptionBudget *DefaultPodDisruptionBudgetConfig `protobuf:"bytes,4,opt,name=defaultPodDisruptionBudget,proto3" json:"defaultPodDisruptionBudget,omitempty"`
	// Selects whether policy enforcement is installed.
	DisablePolicyChecks bool                    `protobuf:"varint,5,opt,name=disablePolicyChecks,proto3" json:"disablePolicyChecks,omitempty"`
	DefaultResources    *DefaultResourcesConfig `protobuf:"bytes,6,opt,name=defaultResources,proto3" json:"defaultResources,omitempty"`
	// Enable helm test
	EnableHelmTest bool `protobuf:"varint,7,opt,name=enableHelmTest,proto3" json:"enableHelmTest,omitempty"`
	// Enables tracing.
	EnableTracing bool `protobuf:"varint,8,opt,name=enableTracing,proto3" json:"enableTracing,omitempty"`
	// Root for docker image paths.
	Hub string `protobuf:"bytes,9,opt,name=hub,proto3" json:"hub,omitempty"`
	// ImagePullPolicy             corev1.PullPolicy                 `json:"imagePullPolicy,omitempty"`
	// Default namespace.
	IstioNamespace    string                   `protobuf:"bytes,10,opt,name=istioNamespace,proto3" json:"istioNamespace,omitempty"`
	LocalityLbSetting map[string]string        `protobuf:"bytes,32,rep,name=localityLbSetting,proto3" json:"localityLbSetting,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	K8SIngress        *KubernetesIngressConfig `protobuf:"bytes,11,opt,name=k8sIngress,proto3" json:"k8sIngress,omitempty"`
	Logging           *GlobalLoggingConfig     `protobuf:"bytes,12,opt,name=logging,proto3" json:"logging,omitempty"`
	MeshExpansion     *MeshExpansionConfig     `protobuf:"bytes,13,opt,name=meshExpansion,proto3" json:"meshExpansion,omitempty"`
	MeshNetworks      map[string]string        `protobuf:"bytes,33,rep,name=meshNetworks,proto3" json:"meshNetworks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Monitor port number for all control plane components.
	MonitoringPort uint32              `protobuf:"varint,14,opt,name=monitoringPort,proto3" json:"monitoringPort,omitempty"`
	Mtls           *MTLSConfig         `protobuf:"bytes,15,opt,name=mtls,proto3" json:"mtls,omitempty"`
	MultiCluster   *MultiClusterConfig `protobuf:"bytes,16,opt,name=multiCluster,proto3" json:"multiCluster,omitempty"`
	// Restricts the applications namespace that the controller manages.
	OneNamespace          bool                         `protobuf:"varint,17,opt,name=oneNamespace,proto3" json:"oneNamespace,omitempty"`
	OutboundTrafficPolicy *OutboundTrafficPolicyConfig `protobuf:"bytes,18,opt,name=outboundTrafficPolicy,proto3" json:"outboundTrafficPolicy,omitempty"`
	// If set, allows traffic in cases when the mixer policy service cannot be reached.
	PolicyCheckFailOpen bool `protobuf:"varint,19,opt,name=policyCheckFailOpen,proto3" json:"policyCheckFailOpen,omitempty"`
	// Namespace of policy components
	PolicyNamespace string `protobuf:"bytes,20,opt,name=policyNamespace,proto3" json:"policyNamespace,omitempty"`
	// k8s priorityClassName.
	PriorityClassName string           `protobuf:"bytes,21,opt,name=priorityClassName,proto3" json:"priorityClassName,omitempty"`
	Proxy             *ProxyConfig     `protobuf:"bytes,22,opt,name=proxy,proto3" json:"proxy,omitempty"`
	ProxyInit         *ProxyInitConfig `protobuf:"bytes,23,opt,name=proxy_init,json=proxyInit,proto3" json:"proxy_init,omitempty"`
	Sds               *SDSConfig       `protobuf:"bytes,24,opt,name=sds,proto3" json:"sds,omitempty"`
	// Version tag for docker images.
	Tag string `protobuf:"bytes,25,opt,name=tag,proto3" json:"tag,omitempty"`
	// Namespace of telemetry components
	TelemetryNamespace string `protobuf:"bytes,26,opt,name=telemetryNamespace,proto3" json:"telemetryNamespace,omitempty"`
	// test
	Tracer *TracerConfig `protobuf:"bytes,27,opt,name=tracer,proto3" json:"tracer,omitempty"`
	// Specifies the trust domain that corresponds to the root cert of CA.
	TrustDomain string `protobuf:"bytes,28,opt,name=trustDomain,proto3" json:"trustDomain,omitempty"`
	// Selects use of Mesh Configuration Protocol to configure Pilot.
	UseMCP               bool     `protobuf:"varint,29,opt,name=useMCP,proto3" json:"useMCP,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GlobalConfig) Reset()         { *m = GlobalConfig{} }
func (m *GlobalConfig) String() string { return proto.CompactTextString(m) }
func (*GlobalConfig) ProtoMessage()    {}
func (*GlobalConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{13}
}
func (m *GlobalConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalConfig.Merge(m, src)
}
func (m *GlobalConfig) XXX_Size() int {
	return m.Size()
}
func (m *GlobalConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalConfig proto.InternalMessageInfo

func (m *GlobalConfig) GetArch() *ArchConfig {
	if m != nil {
		return m.Arch
	}
	return nil
}

func (m *GlobalConfig) GetConfigNamespace() string {
	if m != nil {
		return m.ConfigNamespace
	}
	return ""
}

func (m *GlobalConfig) GetConfigValidation() bool {
	if m != nil {
		return m.ConfigValidation
	}
	return false
}

func (m *GlobalConfig) GetControlPlaneSecurityEnabled() bool {
	if m != nil {
		return m.ControlPlaneSecurityEnabled
	}
	return false
}

func (m *GlobalConfig) GetDefaultNodeSelector() map[string]string {
	if m != nil {
		return m.DefaultNodeSelector
	}
	return nil
}

func (m *GlobalConfig) GetDefaultPodDisruptionBudget() *DefaultPodDisruptionBudgetConfig {
	if m != nil {
		return m.DefaultPodDisruptionBudget
	}
	return nil
}

func (m *GlobalConfig) GetDisablePolicyChecks() bool {
	if m != nil {
		return m.DisablePolicyChecks
	}
	return false
}

func (m *GlobalConfig) GetDefaultResources() *DefaultResourcesConfig {
	if m != nil {
		return m.DefaultResources
	}
	return nil
}

func (m *GlobalConfig) GetEnableHelmTest() bool {
	if m != nil {
		return m.EnableHelmTest
	}
	return false
}

func (m *GlobalConfig) GetEnableTracing() bool {
	if m != nil {
		return m.EnableTracing
	}
	return false
}

func (m *GlobalConfig) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *GlobalConfig) GetIstioNamespace() string {
	if m != nil {
		return m.IstioNamespace
	}
	return ""
}

func (m *GlobalConfig) GetLocalityLbSetting() map[string]string {
	if m != nil {
		return m.LocalityLbSetting
	}
	return nil
}

func (m *GlobalConfig) GetK8SIngress() *KubernetesIngressConfig {
	if m != nil {
		return m.K8SIngress
	}
	return nil
}

func (m *GlobalConfig) GetLogging() *GlobalLoggingConfig {
	if m != nil {
		return m.Logging
	}
	return nil
}

func (m *GlobalConfig) GetMeshExpansion() *MeshExpansionConfig {
	if m != nil {
		return m.MeshExpansion
	}
	return nil
}

func (m *GlobalConfig) GetMeshNetworks() map[string]string {
	if m != nil {
		return m.MeshNetworks
	}
	return nil
}

func (m *GlobalConfig) GetMonitoringPort() uint32 {
	if m != nil {
		return m.MonitoringPort
	}
	return 0
}

func (m *GlobalConfig) GetMtls() *MTLSConfig {
	if m != nil {
		return m.Mtls
	}
	return nil
}

func (m *GlobalConfig) GetMultiCluster() *MultiClusterConfig {
	if m != nil {
		return m.MultiCluster
	}
	return nil
}

func (m *GlobalConfig) GetOneNamespace() bool {
	if m != nil {
		return m.OneNamespace
	}
	return false
}

func (m *GlobalConfig) GetOutboundTrafficPolicy() *OutboundTrafficPolicyConfig {
	if m != nil {
		return m.OutboundTrafficPolicy
	}
	return nil
}

func (m *GlobalConfig) GetPolicyCheckFailOpen() bool {
	if m != nil {
		return m.PolicyCheckFailOpen
	}
	return false
}

func (m *GlobalConfig) GetPolicyNamespace() string {
	if m != nil {
		return m.PolicyNamespace
	}
	return ""
}

func (m *GlobalConfig) GetPriorityClassName() string {
	if m != nil {
		return m.PriorityClassName
	}
	return ""
}

func (m *GlobalConfig) GetProxy() *ProxyConfig {
	if m != nil {
		return m.Proxy
	}
	return nil
}

func (m *GlobalConfig) GetProxyInit() *ProxyInitConfig {
	if m != nil {
		return m.ProxyInit
	}
	return nil
}

func (m *GlobalConfig) GetSds() *SDSConfig {
	if m != nil {
		return m.Sds
	}
	return nil
}

func (m *GlobalConfig) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *GlobalConfig) GetTelemetryNamespace() string {
	if m != nil {
		return m.TelemetryNamespace
	}
	return ""
}

func (m *GlobalConfig) GetTracer() *TracerConfig {
	if m != nil {
		return m.Tracer
	}
	return nil
}

func (m *GlobalConfig) GetTrustDomain() string {
	if m != nil {
		return m.TrustDomain
	}
	return ""
}

func (m *GlobalConfig) GetUseMCP() bool {
	if m != nil {
		return m.UseMCP
	}
	return false
}

// GlobalLoggingConfig is described in istio.io documentation.
type GlobalLoggingConfig struct {
	Level                string   `protobuf:"bytes,1,opt,name=level,proto3" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GlobalLoggingConfig) Reset()         { *m = GlobalLoggingConfig{} }
func (m *GlobalLoggingConfig) String() string { return proto.CompactTextString(m) }
func (*GlobalLoggingConfig) ProtoMessage()    {}
func (*GlobalLoggingConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{14}
}
func (m *GlobalLoggingConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalLoggingConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalLoggingConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalLoggingConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalLoggingConfig.Merge(m, src)
}
func (m *GlobalLoggingConfig) XXX_Size() int {
	return m.Size()
}
func (m *GlobalLoggingConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalLoggingConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalLoggingConfig proto.InternalMessageInfo

func (m *GlobalLoggingConfig) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

// ILBGatewayConfig is described in istio.io documentation.
type ILBGatewayConfig struct {
	AutoscaleEnabled bool                        `protobuf:"varint,1,opt,name=autoscaleEnabled,proto3" json:"autoscaleEnabled,omitempty"`
	AutoscaleMax     uint32                      `protobuf:"varint,2,opt,name=autoscaleMax,proto3" json:"autoscaleMax,omitempty"`
	AutoscaleMin     uint32                      `protobuf:"varint,3,opt,name=autoscaleMin,proto3" json:"autoscaleMin,omitempty"`
	Enabled          bool                        `protobuf:"varint,4,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Cpu              *CPUTargetUtilizationConfig `protobuf:"bytes,5,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Labels           *GatewayLabelsConfig        `protobuf:"bytes,6,opt,name=labels,proto3" json:"labels,omitempty"`
	LoadBalancerIP   string                      `protobuf:"bytes,7,opt,name=loadBalancerIP,proto3" json:"loadBalancerIP,omitempty"`
	// 	NodeSelector       map[string]interface{}      `json:"nodeSelector,omitempty"`
	// 	PodAnnotations     map[string]interface{}      `json:"podAnnotations,omitempty"`
	Ports                []*PortsConfig           `protobuf:"bytes,8,rep,name=ports,proto3" json:"ports,omitempty"`
	Resources            *v1.ResourceRequirements `protobuf:"bytes,9,opt,name=resources,proto3" json:"resources,omitempty"`
	SecretVolumes        []*SecretVolume          `protobuf:"bytes,10,rep,name=secretVolumes,proto3" json:"secretVolumes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ILBGatewayConfig) Reset()         { *m = ILBGatewayConfig{} }
func (m *ILBGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*ILBGatewayConfig) ProtoMessage()    {}
func (*ILBGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{15}
}
func (m *ILBGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ILBGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ILBGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ILBGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ILBGatewayConfig.Merge(m, src)
}
func (m *ILBGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *ILBGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ILBGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ILBGatewayConfig proto.InternalMessageInfo

func (m *ILBGatewayConfig) GetAutoscaleEnabled() bool {
	if m != nil {
		return m.AutoscaleEnabled
	}
	return false
}

func (m *ILBGatewayConfig) GetAutoscaleMax() uint32 {
	if m != nil {
		return m.AutoscaleMax
	}
	return 0
}

func (m *ILBGatewayConfig) GetAutoscaleMin() uint32 {
	if m != nil {
		return m.AutoscaleMin
	}
	return 0
}

func (m *ILBGatewayConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *ILBGatewayConfig) GetCpu() *CPUTargetUtilizationConfig {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *ILBGatewayConfig) GetLabels() *GatewayLabelsConfig {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ILBGatewayConfig) GetLoadBalancerIP() string {
	if m != nil {
		return m.LoadBalancerIP
	}
	return ""
}

func (m *ILBGatewayConfig) GetPorts() []*PortsConfig {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ILBGatewayConfig) GetResources() *v1.ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ILBGatewayConfig) GetSecretVolumes() []*SecretVolume {
	if m != nil {
		return m.SecretVolumes
	}
	return nil
}

// IngressGatewayConfig is described in istio.io documentation.
type IngressGatewayConfig struct {
	AutoscaleEnabled         bool                        `protobuf:"varint,1,opt,name=autoscaleEnabled,proto3" json:"autoscaleEnabled,omitempty"`
	AutoscaleMax             uint32                      `protobuf:"varint,2,opt,name=autoscaleMax,proto3" json:"autoscaleMax,omitempty"`
	AutoscaleMin             uint32                      `protobuf:"varint,3,opt,name=autoscaleMin,proto3" json:"autoscaleMin,omitempty"`
	ConnectTimeout           string                      `protobuf:"bytes,4,opt,name=connectTimeout,proto3" json:"connectTimeout,omitempty"`
	Cpu                      *CPUTargetUtilizationConfig `protobuf:"bytes,5,opt,name=cpu,proto3" json:"cpu,omitempty"`
	CustomService            bool                        `protobuf:"varint,6,opt,name=customService,proto3" json:"customService,omitempty"`
	Debug                    string                      `protobuf:"bytes,7,opt,name=debug,proto3" json:"debug,omitempty"`
	Domain                   string                      `protobuf:"bytes,8,opt,name=domain,proto3" json:"domain,omitempty"`
	DrainDuration            *duration.Duration          `protobuf:"bytes,9,opt,name=drainDuration,proto3" json:"drainDuration,omitempty"`
	Enabled                  bool                        `protobuf:"varint,10,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Env                      map[string]string           `protobuf:"bytes,11,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ExternalIPs              []string                    `protobuf:"bytes,12,rep,name=externalIPs,proto3" json:"externalIPs,omitempty"`
	K8SIngress               bool                        `protobuf:"varint,13,opt,name=k8sIngress,proto3" json:"k8sIngress,omitempty"`
	K8SIngressHttps          bool                        `protobuf:"varint,14,opt,name=k8sIngressHttps,proto3" json:"k8sIngressHttps,omitempty"`
	Labels                   *GatewayLabelsConfig        `protobuf:"bytes,15,opt,name=labels,proto3" json:"labels,omitempty"`
	LoadBalancerIP           string                      `protobuf:"bytes,16,opt,name=loadBalancerIP,proto3" json:"loadBalancerIP,omitempty"`
	LoadBalancerSourceRanges []string                    `protobuf:"bytes,17,rep,name=loadBalancerSourceRanges,proto3" json:"loadBalancerSourceRanges,omitempty"`
	MeshExpansionPorts       []*PortsConfig              `protobuf:"bytes,18,rep,name=meshExpansionPorts,proto3" json:"meshExpansionPorts,omitempty"`
	// 	NodeSelector                     map[string]interface{}      `json:"nodeSelector,omitempty"`
	// 	PodAnnotations                   map[string]interface{}      `json:"podAnnotations,omitempty"`
	// 	PodAntiAffinityLabelSelector     []map[string]interface{}    `json:"podAntiAffinityLabelSelector"`
	// 	PodAntiAffinityTermLabelSelector []map[string]interface{}    `json:"podAntiAffinityTermLabelSelector"`
	Ports        []*PortsConfig `protobuf:"bytes,19,rep,name=ports,proto3" json:"ports,omitempty"`
	ReplicaCount uint32         `protobuf:"varint,20,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	// 	Resources                        map[string]interface{}      `json:"resources,omitempty"`
	Sds           *IngressGatewaySdsConfig `protobuf:"bytes,21,opt,name=sds,proto3" json:"sds,omitempty"`
	SecretVolumes []*SecretVolume          `protobuf:"bytes,22,rep,name=secretVolumes,proto3" json:"secretVolumes,omitempty"`
	// 	ServiceAnnotations               map[string]interface{}      `json:"serviceAnnotations,omitempty"`
	//    Type                             corev1.ServiceType          `json:"type,omitempty"`
	Zvpn                 *IngressGatewayZvpnConfig `protobuf:"bytes,23,opt,name=zvpn,proto3" json:"zvpn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *IngressGatewayConfig) Reset()         { *m = IngressGatewayConfig{} }
func (m *IngressGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*IngressGatewayConfig) ProtoMessage()    {}
func (*IngressGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{16}
}
func (m *IngressGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGatewayConfig.Merge(m, src)
}
func (m *IngressGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *IngressGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGatewayConfig proto.InternalMessageInfo

func (m *IngressGatewayConfig) GetAutoscaleEnabled() bool {
	if m != nil {
		return m.AutoscaleEnabled
	}
	return false
}

func (m *IngressGatewayConfig) GetAutoscaleMax() uint32 {
	if m != nil {
		return m.AutoscaleMax
	}
	return 0
}

func (m *IngressGatewayConfig) GetAutoscaleMin() uint32 {
	if m != nil {
		return m.AutoscaleMin
	}
	return 0
}

func (m *IngressGatewayConfig) GetConnectTimeout() string {
	if m != nil {
		return m.ConnectTimeout
	}
	return ""
}

func (m *IngressGatewayConfig) GetCpu() *CPUTargetUtilizationConfig {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *IngressGatewayConfig) GetCustomService() bool {
	if m != nil {
		return m.CustomService
	}
	return false
}

func (m *IngressGatewayConfig) GetDebug() string {
	if m != nil {
		return m.Debug
	}
	return ""
}

func (m *IngressGatewayConfig) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *IngressGatewayConfig) GetDrainDuration() *duration.Duration {
	if m != nil {
		return m.DrainDuration
	}
	return nil
}

func (m *IngressGatewayConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *IngressGatewayConfig) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *IngressGatewayConfig) GetExternalIPs() []string {
	if m != nil {
		return m.ExternalIPs
	}
	return nil
}

func (m *IngressGatewayConfig) GetK8SIngress() bool {
	if m != nil {
		return m.K8SIngress
	}
	return false
}

func (m *IngressGatewayConfig) GetK8SIngressHttps() bool {
	if m != nil {
		return m.K8SIngressHttps
	}
	return false
}

func (m *IngressGatewayConfig) GetLabels() *GatewayLabelsConfig {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *IngressGatewayConfig) GetLoadBalancerIP() string {
	if m != nil {
		return m.LoadBalancerIP
	}
	return ""
}

func (m *IngressGatewayConfig) GetLoadBalancerSourceRanges() []string {
	if m != nil {
		return m.LoadBalancerSourceRanges
	}
	return nil
}

func (m *IngressGatewayConfig) GetMeshExpansionPorts() []*PortsConfig {
	if m != nil {
		return m.MeshExpansionPorts
	}
	return nil
}

func (m *IngressGatewayConfig) GetPorts() []*PortsConfig {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *IngressGatewayConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *IngressGatewayConfig) GetSds() *IngressGatewaySdsConfig {
	if m != nil {
		return m.Sds
	}
	return nil
}

func (m *IngressGatewayConfig) GetSecretVolumes() []*SecretVolume {
	if m != nil {
		return m.SecretVolumes
	}
	return nil
}

func (m *IngressGatewayConfig) GetZvpn() *IngressGatewayZvpnConfig {
	if m != nil {
		return m.Zvpn
	}
	return nil
}

// IngressGatewaySdsConfig is described in istio.io documentation.
type IngressGatewaySdsConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Image                string   `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IngressGatewaySdsConfig) Reset()         { *m = IngressGatewaySdsConfig{} }
func (m *IngressGatewaySdsConfig) String() string { return proto.CompactTextString(m) }
func (*IngressGatewaySdsConfig) ProtoMessage()    {}
func (*IngressGatewaySdsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{17}
}
func (m *IngressGatewaySdsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGatewaySdsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGatewaySdsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGatewaySdsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGatewaySdsConfig.Merge(m, src)
}
func (m *IngressGatewaySdsConfig) XXX_Size() int {
	return m.Size()
}
func (m *IngressGatewaySdsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGatewaySdsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGatewaySdsConfig proto.InternalMessageInfo

func (m *IngressGatewaySdsConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *IngressGatewaySdsConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

// IngressGatewayZvpnConfig is described in istio.io documentation.
type IngressGatewayZvpnConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Suffix               string   `protobuf:"bytes,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IngressGatewayZvpnConfig) Reset()         { *m = IngressGatewayZvpnConfig{} }
func (m *IngressGatewayZvpnConfig) String() string { return proto.CompactTextString(m) }
func (*IngressGatewayZvpnConfig) ProtoMessage()    {}
func (*IngressGatewayZvpnConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{18}
}
func (m *IngressGatewayZvpnConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGatewayZvpnConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGatewayZvpnConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGatewayZvpnConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGatewayZvpnConfig.Merge(m, src)
}
func (m *IngressGatewayZvpnConfig) XXX_Size() int {
	return m.Size()
}
func (m *IngressGatewayZvpnConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGatewayZvpnConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGatewayZvpnConfig proto.InternalMessageInfo

func (m *IngressGatewayZvpnConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *IngressGatewayZvpnConfig) GetSuffix() string {
	if m != nil {
		return m.Suffix
	}
	return ""
}

// KubernetesEnvMixerAdapterConfig is described in istio.io documentation.
type KubernetesEnvMixerAdapterConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesEnvMixerAdapterConfig) Reset()         { *m = KubernetesEnvMixerAdapterConfig{} }
func (m *KubernetesEnvMixerAdapterConfig) String() string { return proto.CompactTextString(m) }
func (*KubernetesEnvMixerAdapterConfig) ProtoMessage()    {}
func (*KubernetesEnvMixerAdapterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{19}
}
func (m *KubernetesEnvMixerAdapterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesEnvMixerAdapterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesEnvMixerAdapterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesEnvMixerAdapterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesEnvMixerAdapterConfig.Merge(m, src)
}
func (m *KubernetesEnvMixerAdapterConfig) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesEnvMixerAdapterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesEnvMixerAdapterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesEnvMixerAdapterConfig proto.InternalMessageInfo

func (m *KubernetesEnvMixerAdapterConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// KubernetesIngressConfig represents the configuration for Kubernetes Ingress.
type KubernetesIngressConfig struct {
	// Enables gateway for legacy k8s Ingress.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Enables gateway for legacy k8s Ingress.
	EnableHttps bool `protobuf:"varint,2,opt,name=enableHttps,proto3" json:"enableHttps,omitempty"`
	// Sets the gateway name for legacy k8s Ingress.
	GatewayName          string   `protobuf:"bytes,3,opt,name=gatewayName,proto3" json:"gatewayName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesIngressConfig) Reset()         { *m = KubernetesIngressConfig{} }
func (m *KubernetesIngressConfig) String() string { return proto.CompactTextString(m) }
func (*KubernetesIngressConfig) ProtoMessage()    {}
func (*KubernetesIngressConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{20}
}
func (m *KubernetesIngressConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesIngressConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesIngressConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesIngressConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesIngressConfig.Merge(m, src)
}
func (m *KubernetesIngressConfig) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesIngressConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesIngressConfig.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesIngressConfig proto.InternalMessageInfo

func (m *KubernetesIngressConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *KubernetesIngressConfig) GetEnableHttps() bool {
	if m != nil {
		return m.EnableHttps
	}
	return false
}

func (m *KubernetesIngressConfig) GetGatewayName() string {
	if m != nil {
		return m.GatewayName
	}
	return ""
}

// LoadSheddingConfig configs when mixer starts rejecting grpc requests.
type LoadSheddingConfig struct {
	LatencyThreshold     string   `protobuf:"bytes,1,opt,name=latencyThreshold,proto3" json:"latencyThreshold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadSheddingConfig) Reset()         { *m = LoadSheddingConfig{} }
func (m *LoadSheddingConfig) String() string { return proto.CompactTextString(m) }
func (*LoadSheddingConfig) ProtoMessage()    {}
func (*LoadSheddingConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{21}
}
func (m *LoadSheddingConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadSheddingConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadSheddingConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadSheddingConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadSheddingConfig.Merge(m, src)
}
func (m *LoadSheddingConfig) XXX_Size() int {
	return m.Size()
}
func (m *LoadSheddingConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadSheddingConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LoadSheddingConfig proto.InternalMessageInfo

func (m *LoadSheddingConfig) GetLatencyThreshold() string {
	if m != nil {
		return m.LatencyThreshold
	}
	return ""
}

// MTLSConfig is described in istio.io documentation.
type MTLSConfig struct {
	// Enables MTLS for service to service traffic.
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MTLSConfig) Reset()         { *m = MTLSConfig{} }
func (m *MTLSConfig) String() string { return proto.CompactTextString(m) }
func (*MTLSConfig) ProtoMessage()    {}
func (*MTLSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{22}
}
func (m *MTLSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MTLSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MTLSConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MTLSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MTLSConfig.Merge(m, src)
}
func (m *MTLSConfig) XXX_Size() int {
	return m.Size()
}
func (m *MTLSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MTLSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MTLSConfig proto.InternalMessageInfo

func (m *MTLSConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// MeshExpansionConfig is described in istio.io documentation.
type MeshExpansionConfig struct {
	// Exposes Pilot and Citadel mTLS on the ingress gateway.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Exposes Pilot and Citadel mTLS and the plain text Pilot ports on an internal gateway.
	UseILB               bool     `protobuf:"varint,2,opt,name=useILB,proto3" json:"useILB,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MeshExpansionConfig) Reset()         { *m = MeshExpansionConfig{} }
func (m *MeshExpansionConfig) String() string { return proto.CompactTextString(m) }
func (*MeshExpansionConfig) ProtoMessage()    {}
func (*MeshExpansionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{23}
}
func (m *MeshExpansionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeshExpansionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeshExpansionConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeshExpansionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeshExpansionConfig.Merge(m, src)
}
func (m *MeshExpansionConfig) XXX_Size() int {
	return m.Size()
}
func (m *MeshExpansionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MeshExpansionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MeshExpansionConfig proto.InternalMessageInfo

func (m *MeshExpansionConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *MeshExpansionConfig) GetUseILB() bool {
	if m != nil {
		return m.UseILB
	}
	return false
}

// MixerAdaptersConfig is described in istio.io documentation.
type MixerAdaptersConfig struct {
	Kubernetesenv        *KubernetesEnvMixerAdapterConfig `protobuf:"bytes,1,opt,name=kubernetesenv,proto3" json:"kubernetesenv,omitempty"`
	Prometheus           *PrometheusMixerAdapterConfig    `protobuf:"bytes,2,opt,name=prometheus,proto3" json:"prometheus,omitempty"`
	Stdio                *StdioMixerAdapterConfig         `protobuf:"bytes,3,opt,name=stdio,proto3" json:"stdio,omitempty"`
	UseAdapterCRDs       bool                             `protobuf:"varint,4,opt,name=useAdapterCRDs,proto3" json:"useAdapterCRDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *MixerAdaptersConfig) Reset()         { *m = MixerAdaptersConfig{} }
func (m *MixerAdaptersConfig) String() string { return proto.CompactTextString(m) }
func (*MixerAdaptersConfig) ProtoMessage()    {}
func (*MixerAdaptersConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{24}
}
func (m *MixerAdaptersConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MixerAdaptersConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MixerAdaptersConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MixerAdaptersConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MixerAdaptersConfig.Merge(m, src)
}
func (m *MixerAdaptersConfig) XXX_Size() int {
	return m.Size()
}
func (m *MixerAdaptersConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MixerAdaptersConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MixerAdaptersConfig proto.InternalMessageInfo

func (m *MixerAdaptersConfig) GetKubernetesenv() *KubernetesEnvMixerAdapterConfig {
	if m != nil {
		return m.Kubernetesenv
	}
	return nil
}

func (m *MixerAdaptersConfig) GetPrometheus() *PrometheusMixerAdapterConfig {
	if m != nil {
		return m.Prometheus
	}
	return nil
}

func (m *MixerAdaptersConfig) GetStdio() *StdioMixerAdapterConfig {
	if m != nil {
		return m.Stdio
	}
	return nil
}

func (m *MixerAdaptersConfig) GetUseAdapterCRDs() bool {
	if m != nil {
		return m.UseAdapterCRDs
	}
	return false
}

// MixerConfig is described in istio.io documentation.
type MixerConfig struct {
	Adapters             *MixerAdaptersConfig  `protobuf:"bytes,1,opt,name=adapters,proto3" json:"adapters,omitempty"`
	Enabled              bool                  `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Env                  map[string]string     `protobuf:"bytes,3,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Image                string                `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	Policy               *MixerPolicyConfig    `protobuf:"bytes,5,opt,name=policy,proto3" json:"policy,omitempty"`
	Telemetry            *MixerTelemetryConfig `protobuf:"bytes,6,opt,name=telemetry,proto3" json:"telemetry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MixerConfig) Reset()         { *m = MixerConfig{} }
func (m *MixerConfig) String() string { return proto.CompactTextString(m) }
func (*MixerConfig) ProtoMessage()    {}
func (*MixerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{25}
}
func (m *MixerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MixerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MixerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MixerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MixerConfig.Merge(m, src)
}
func (m *MixerConfig) XXX_Size() int {
	return m.Size()
}
func (m *MixerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MixerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MixerConfig proto.InternalMessageInfo

func (m *MixerConfig) GetAdapters() *MixerAdaptersConfig {
	if m != nil {
		return m.Adapters
	}
	return nil
}

func (m *MixerConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *MixerConfig) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *MixerConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *MixerConfig) GetPolicy() *MixerPolicyConfig {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *MixerConfig) GetTelemetry() *MixerTelemetryConfig {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

// MixerPolicyConfig is described in istio.io documentation.
type MixerPolicyConfig struct {
	AutoscaleEnabled bool                        `protobuf:"varint,1,opt,name=autoscaleEnabled,proto3" json:"autoscaleEnabled,omitempty"`
	AutoscaleMax     uint32                      `protobuf:"varint,2,opt,name=autoscaleMax,proto3" json:"autoscaleMax,omitempty"`
	AutoscaleMin     uint32                      `protobuf:"varint,3,opt,name=autoscaleMin,proto3" json:"autoscaleMin,omitempty"`
	Cpu              *CPUTargetUtilizationConfig `protobuf:"bytes,4,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Enabled          bool                        `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Image            string                      `protobuf:"bytes,6,opt,name=image,proto3" json:"image,omitempty"`
	// 	PodAnnotations   map[string]interface{}      `json:"podAnnotations,omitempty"`
	ReplicaCount         uint32   `protobuf:"varint,7,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MixerPolicyConfig) Reset()         { *m = MixerPolicyConfig{} }
func (m *MixerPolicyConfig) String() string { return proto.CompactTextString(m) }
func (*MixerPolicyConfig) ProtoMessage()    {}
func (*MixerPolicyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{26}
}
func (m *MixerPolicyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MixerPolicyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MixerPolicyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MixerPolicyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MixerPolicyConfig.Merge(m, src)
}
func (m *MixerPolicyConfig) XXX_Size() int {
	return m.Size()
}
func (m *MixerPolicyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MixerPolicyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MixerPolicyConfig proto.InternalMessageInfo

func (m *MixerPolicyConfig) GetAutoscaleEnabled() bool {
	if m != nil {
		return m.AutoscaleEnabled
	}
	return false
}

func (m *MixerPolicyConfig) GetAutoscaleMax() uint32 {
	if m != nil {
		return m.AutoscaleMax
	}
	return 0
}

func (m *MixerPolicyConfig) GetAutoscaleMin() uint32 {
	if m != nil {
		return m.AutoscaleMin
	}
	return 0
}

func (m *MixerPolicyConfig) GetCpu() *CPUTargetUtilizationConfig {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *MixerPolicyConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *MixerPolicyConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *MixerPolicyConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

// MixerTelemetryConfig is described in istio.io documentation.
type MixerTelemetryConfig struct {
	Adapters         *MixerAdaptersConfig        `protobuf:"bytes,1,opt,name=adapters,proto3" json:"adapters,omitempty"`
	AutoscaleEnabled bool                        `protobuf:"varint,2,opt,name=autoscaleEnabled,proto3" json:"autoscaleEnabled,omitempty"`
	AutoscaleMax     uint32                      `protobuf:"varint,3,opt,name=autoscaleMax,proto3" json:"autoscaleMax,omitempty"`
	AutoscaleMin     uint32                      `protobuf:"varint,4,opt,name=autoscaleMin,proto3" json:"autoscaleMin,omitempty"`
	Cpu              *CPUTargetUtilizationConfig `protobuf:"bytes,5,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Enabled          bool                        `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Env              map[string]string           `protobuf:"bytes,7,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Image            string                      `protobuf:"bytes,8,opt,name=image,proto3" json:"image,omitempty"`
	Loadshedding     *LoadSheddingConfig         `protobuf:"bytes,9,opt,name=loadshedding,proto3" json:"loadshedding,omitempty"`
	// 	NodeSelector           map[string]interface{}     `json:"nodeSelector,omitempty"`
	// 	PodAnnotations         map[string]interface{}     `json:"podAnnotations,omitempty"`
	ReplicaCount           uint32                   `protobuf:"varint,10,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	Resources              *v1.ResourceRequirements `protobuf:"bytes,11,opt,name=resources,proto3" json:"resources,omitempty"`
	SessionAffinityEnabled bool                     `protobuf:"varint,12,opt,name=sessionAffinityEnabled,proto3" json:"sessionAffinityEnabled,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                 `json:"-"`
	XXX_unrecognized       []byte                   `json:"-"`
	XXX_sizecache          int32                    `json:"-"`
}

func (m *MixerTelemetryConfig) Reset()         { *m = MixerTelemetryConfig{} }
func (m *MixerTelemetryConfig) String() string { return proto.CompactTextString(m) }
func (*MixerTelemetryConfig) ProtoMessage()    {}
func (*MixerTelemetryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{27}
}
func (m *MixerTelemetryConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MixerTelemetryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MixerTelemetryConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MixerTelemetryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MixerTelemetryConfig.Merge(m, src)
}
func (m *MixerTelemetryConfig) XXX_Size() int {
	return m.Size()
}
func (m *MixerTelemetryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MixerTelemetryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MixerTelemetryConfig proto.InternalMessageInfo

func (m *MixerTelemetryConfig) GetAdapters() *MixerAdaptersConfig {
	if m != nil {
		return m.Adapters
	}
	return nil
}

func (m *MixerTelemetryConfig) GetAutoscaleEnabled() bool {
	if m != nil {
		return m.AutoscaleEnabled
	}
	return false
}

func (m *MixerTelemetryConfig) GetAutoscaleMax() uint32 {
	if m != nil {
		return m.AutoscaleMax
	}
	return 0
}

func (m *MixerTelemetryConfig) GetAutoscaleMin() uint32 {
	if m != nil {
		return m.AutoscaleMin
	}
	return 0
}

func (m *MixerTelemetryConfig) GetCpu() *CPUTargetUtilizationConfig {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *MixerTelemetryConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *MixerTelemetryConfig) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *MixerTelemetryConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *MixerTelemetryConfig) GetLoadshedding() *LoadSheddingConfig {
	if m != nil {
		return m.Loadshedding
	}
	return nil
}

func (m *MixerTelemetryConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *MixerTelemetryConfig) GetResources() *v1.ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *MixerTelemetryConfig) GetSessionAffinityEnabled() bool {
	if m != nil {
		return m.SessionAffinityEnabled
	}
	return false
}

// MultiClusterConfig is described in istio.io documentation.
type MultiClusterConfig struct {
	// Enables the connection between two kubernetes clusters via their respective ingressgateway services. Use if the pods in each cluster cannot directly talk to one another.
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MultiClusterConfig) Reset()         { *m = MultiClusterConfig{} }
func (m *MultiClusterConfig) String() string { return proto.CompactTextString(m) }
func (*MultiClusterConfig) ProtoMessage()    {}
func (*MultiClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{28}
}
func (m *MultiClusterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiClusterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiClusterConfig.Merge(m, src)
}
func (m *MultiClusterConfig) XXX_Size() int {
	return m.Size()
}
func (m *MultiClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MultiClusterConfig proto.InternalMessageInfo

func (m *MultiClusterConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// NodeAgentConfig is described in istio.io documentation.
type NodeAgentConfig struct {
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// 	Env          map[string]interface{} `json:"env,omitempty"`
	Image                string   `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeAgentConfig) Reset()         { *m = NodeAgentConfig{} }
func (m *NodeAgentConfig) String() string { return proto.CompactTextString(m) }
func (*NodeAgentConfig) ProtoMessage()    {}
func (*NodeAgentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{29}
}
func (m *NodeAgentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeAgentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeAgentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeAgentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAgentConfig.Merge(m, src)
}
func (m *NodeAgentConfig) XXX_Size() int {
	return m.Size()
}
func (m *NodeAgentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAgentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAgentConfig proto.InternalMessageInfo

func (m *NodeAgentConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *NodeAgentConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

// OutboundTrafficPolicyConfig is described in istio.io documentation.
type OutboundTrafficPolicyConfig struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutboundTrafficPolicyConfig) Reset()         { *m = OutboundTrafficPolicyConfig{} }
func (m *OutboundTrafficPolicyConfig) String() string { return proto.CompactTextString(m) }
func (*OutboundTrafficPolicyConfig) ProtoMessage()    {}
func (*OutboundTrafficPolicyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{30}
}
func (m *OutboundTrafficPolicyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutboundTrafficPolicyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutboundTrafficPolicyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutboundTrafficPolicyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutboundTrafficPolicyConfig.Merge(m, src)
}
func (m *OutboundTrafficPolicyConfig) XXX_Size() int {
	return m.Size()
}
func (m *OutboundTrafficPolicyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_OutboundTrafficPolicyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_OutboundTrafficPolicyConfig proto.InternalMessageInfo

// PilotConfig is described in istio.io documentation.
type PilotConfig struct {
	Enabled          bool                        `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	AutoscaleEnabled bool                        `protobuf:"varint,2,opt,name=autoscaleEnabled,proto3" json:"autoscaleEnabled,omitempty"`
	AutoscaleMin     uint32                      `protobuf:"varint,3,opt,name=autoscaleMin,proto3" json:"autoscaleMin,omitempty"`
	AutoscaleMax     uint32                      `protobuf:"varint,4,opt,name=autoscaleMax,proto3" json:"autoscaleMax,omitempty"`
	ReplicaCount     uint32                      `protobuf:"varint,5,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	Image            string                      `protobuf:"bytes,6,opt,name=image,proto3" json:"image,omitempty"`
	Sidecar          bool                        `protobuf:"varint,7,opt,name=sidecar,proto3" json:"sidecar,omitempty"`
	TraceSampling    float64                     `protobuf:"fixed64,8,opt,name=traceSampling,proto3" json:"traceSampling,omitempty"`
	Resources        *v1.ResourceRequirements    `protobuf:"bytes,9,opt,name=resources,proto3" json:"resources,omitempty"`
	ConfigNamespace  string                      `protobuf:"bytes,10,opt,name=configNamespace,proto3" json:"configNamespace,omitempty"`
	Cpu              *CPUTargetUtilizationConfig `protobuf:"bytes,11,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// 	NodeSelector                     map[string]interface{}      `json:"nodeSelector,omitempty"`
	KeepaliveMaxServerConnectionAge *duration.Duration `protobuf:"bytes,12,opt,name=keepaliveMaxServerConnectionAge,proto3" json:"keepaliveMaxServerConnectionAge,omitempty"`
	DeploymentLabels                map[string]string  `protobuf:"bytes,13,rep,name=deploymentLabels,proto3" json:"deploymentLabels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 	MeshNetworks                     map[string]interface{}      `json:"meshNetworks,omitempty"`
	// 	PodAntiAffinityLabelSelector     []map[string]interface{}    `json:"podAntiAffinityLabelSelector"`
	// 	PodAntiAffinityTermLabelSelector []map[string]interface{}    `json:"podAntiAffinityTermLabelSelector"`
	ConfigMap            bool                  `protobuf:"varint,14,opt,name=configMap,proto3" json:"configMap,omitempty"`
	Ingress              *PilotIngressConfig   `protobuf:"bytes,15,opt,name=ingress,proto3" json:"ingress,omitempty"`
	UseMCP               bool                  `protobuf:"varint,16,opt,name=useMCP,proto3" json:"useMCP,omitempty"`
	Env                  map[string]string     `protobuf:"bytes,17,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Policy               *PilotPolicyConfig    `protobuf:"bytes,18,opt,name=policy,proto3" json:"policy,omitempty"`
	Telemetry            *PilotTelemetryConfig `protobuf:"bytes,19,opt,name=telemetry,proto3" json:"telemetry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PilotConfig) Reset()         { *m = PilotConfig{} }
func (m *PilotConfig) String() string { return proto.CompactTextString(m) }
func (*PilotConfig) ProtoMessage()    {}
func (*PilotConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{31}
}
func (m *PilotConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotConfig.Merge(m, src)
}
func (m *PilotConfig) XXX_Size() int {
	return m.Size()
}
func (m *PilotConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PilotConfig proto.InternalMessageInfo

func (m *PilotConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *PilotConfig) GetAutoscaleEnabled() bool {
	if m != nil {
		return m.AutoscaleEnabled
	}
	return false
}

func (m *PilotConfig) GetAutoscaleMin() uint32 {
	if m != nil {
		return m.AutoscaleMin
	}
	return 0
}

func (m *PilotConfig) GetAutoscaleMax() uint32 {
	if m != nil {
		return m.AutoscaleMax
	}
	return 0
}

func (m *PilotConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *PilotConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *PilotConfig) GetSidecar() bool {
	if m != nil {
		return m.Sidecar
	}
	return false
}

func (m *PilotConfig) GetTraceSampling() float64 {
	if m != nil {
		return m.TraceSampling
	}
	return 0
}

func (m *PilotConfig) GetResources() *v1.ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *PilotConfig) GetConfigNamespace() string {
	if m != nil {
		return m.ConfigNamespace
	}
	return ""
}

func (m *PilotConfig) GetCpu() *CPUTargetUtilizationConfig {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *PilotConfig) GetKeepaliveMaxServerConnectionAge() *duration.Duration {
	if m != nil {
		return m.KeepaliveMaxServerConnectionAge
	}
	return nil
}

func (m *PilotConfig) GetDeploymentLabels() map[string]string {
	if m != nil {
		return m.DeploymentLabels
	}
	return nil
}

func (m *PilotConfig) GetConfigMap() bool {
	if m != nil {
		return m.ConfigMap
	}
	return false
}

func (m *PilotConfig) GetIngress() *PilotIngressConfig {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *PilotConfig) GetUseMCP() bool {
	if m != nil {
		return m.UseMCP
	}
	return false
}

func (m *PilotConfig) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *PilotConfig) GetPolicy() *PilotPolicyConfig {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *PilotConfig) GetTelemetry() *PilotTelemetryConfig {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

// PilotIngressConfig is described in istio.io documentation.
type PilotIngressConfig struct {
	IngressService string `protobuf:"bytes,1,opt,name=ingressService,proto3" json:"ingressService,omitempty"`
	//Value to set on "kubernetes.io/ingress.class" annotations to activate, if mode is STRICT
	IngressClass         string   `protobuf:"bytes,3,opt,name=ingressClass,proto3" json:"ingressClass,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PilotIngressConfig) Reset()         { *m = PilotIngressConfig{} }
func (m *PilotIngressConfig) String() string { return proto.CompactTextString(m) }
func (*PilotIngressConfig) ProtoMessage()    {}
func (*PilotIngressConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{32}
}
func (m *PilotIngressConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotIngressConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotIngressConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotIngressConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotIngressConfig.Merge(m, src)
}
func (m *PilotIngressConfig) XXX_Size() int {
	return m.Size()
}
func (m *PilotIngressConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotIngressConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PilotIngressConfig proto.InternalMessageInfo

func (m *PilotIngressConfig) GetIngressService() string {
	if m != nil {
		return m.IngressService
	}
	return ""
}

func (m *PilotIngressConfig) GetIngressClass() string {
	if m != nil {
		return m.IngressClass
	}
	return ""
}

// PilotPolicyConfig is described in istio.io documentation.
type PilotPolicyConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PilotPolicyConfig) Reset()         { *m = PilotPolicyConfig{} }
func (m *PilotPolicyConfig) String() string { return proto.CompactTextString(m) }
func (*PilotPolicyConfig) ProtoMessage()    {}
func (*PilotPolicyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{33}
}
func (m *PilotPolicyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotPolicyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotPolicyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotPolicyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotPolicyConfig.Merge(m, src)
}
func (m *PilotPolicyConfig) XXX_Size() int {
	return m.Size()
}
func (m *PilotPolicyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotPolicyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PilotPolicyConfig proto.InternalMessageInfo

func (m *PilotPolicyConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// PilotTelemetryConfig is described in istio.io documentation.
type PilotTelemetryConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PilotTelemetryConfig) Reset()         { *m = PilotTelemetryConfig{} }
func (m *PilotTelemetryConfig) String() string { return proto.CompactTextString(m) }
func (*PilotTelemetryConfig) ProtoMessage()    {}
func (*PilotTelemetryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{34}
}
func (m *PilotTelemetryConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotTelemetryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotTelemetryConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotTelemetryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotTelemetryConfig.Merge(m, src)
}
func (m *PilotTelemetryConfig) XXX_Size() int {
	return m.Size()
}
func (m *PilotTelemetryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotTelemetryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PilotTelemetryConfig proto.InternalMessageInfo

func (m *PilotTelemetryConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// PortsConfig is described in istio.io documentation.
type PortsConfig struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Port                 int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	NodePort             int32    `protobuf:"varint,3,opt,name=nodePort,proto3" json:"nodePort,omitempty"`
	TargetPort           int32    `protobuf:"varint,4,opt,name=targetPort,proto3" json:"targetPort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PortsConfig) Reset()         { *m = PortsConfig{} }
func (m *PortsConfig) String() string { return proto.CompactTextString(m) }
func (*PortsConfig) ProtoMessage()    {}
func (*PortsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{35}
}
func (m *PortsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortsConfig.Merge(m, src)
}
func (m *PortsConfig) XXX_Size() int {
	return m.Size()
}
func (m *PortsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PortsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PortsConfig proto.InternalMessageInfo

func (m *PortsConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PortsConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PortsConfig) GetNodePort() int32 {
	if m != nil {
		return m.NodePort
	}
	return 0
}

func (m *PortsConfig) GetTargetPort() int32 {
	if m != nil {
		return m.TargetPort
	}
	return 0
}

// PrometheusConfig is described in istio.io documentation.
type PrometheusConfig struct {
	CreatePrometheusResource bool   `protobuf:"varint,1,opt,name=createPrometheusResource,proto3" json:"createPrometheusResource,omitempty"`
	Enabled                  bool   `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	ReplicaCount             uint32 `protobuf:"varint,3,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	Hub                      string `protobuf:"bytes,4,opt,name=hub,proto3" json:"hub,omitempty"`
	Tag                      string `protobuf:"bytes,5,opt,name=tag,proto3" json:"tag,omitempty"`
	Retention                string `protobuf:"bytes,6,opt,name=retention,proto3" json:"retention,omitempty"`
	// 	NodeSelector             map[string]interface{}    `json:"nodeSelector,omitempty"`
	ScrapeInterval       *duration.Duration        `protobuf:"bytes,7,opt,name=scrapeInterval,proto3" json:"scrapeInterval,omitempty"`
	ContextPath          string                    `protobuf:"bytes,8,opt,name=contextPath,proto3" json:"contextPath,omitempty"`
	Ingress              *AddonIngressConfig       `protobuf:"bytes,9,opt,name=ingress,proto3" json:"ingress,omitempty"`
	Service              *PrometheusServiceConfig  `protobuf:"bytes,10,opt,name=service,proto3" json:"service,omitempty"`
	Security             *PrometheusSecurityConfig `protobuf:"bytes,11,opt,name=security,proto3" json:"security,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *PrometheusConfig) Reset()         { *m = PrometheusConfig{} }
func (m *PrometheusConfig) String() string { return proto.CompactTextString(m) }
func (*PrometheusConfig) ProtoMessage()    {}
func (*PrometheusConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{36}
}
func (m *PrometheusConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrometheusConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrometheusConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrometheusConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrometheusConfig.Merge(m, src)
}
func (m *PrometheusConfig) XXX_Size() int {
	return m.Size()
}
func (m *PrometheusConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PrometheusConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PrometheusConfig proto.InternalMessageInfo

func (m *PrometheusConfig) GetCreatePrometheusResource() bool {
	if m != nil {
		return m.CreatePrometheusResource
	}
	return false
}

func (m *PrometheusConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *PrometheusConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *PrometheusConfig) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *PrometheusConfig) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *PrometheusConfig) GetRetention() string {
	if m != nil {
		return m.Retention
	}
	return ""
}

func (m *PrometheusConfig) GetScrapeInterval() *duration.Duration {
	if m != nil {
		return m.ScrapeInterval
	}
	return nil
}

func (m *PrometheusConfig) GetContextPath() string {
	if m != nil {
		return m.ContextPath
	}
	return ""
}

func (m *PrometheusConfig) GetIngress() *AddonIngressConfig {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *PrometheusConfig) GetService() *PrometheusServiceConfig {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *PrometheusConfig) GetSecurity() *PrometheusSecurityConfig {
	if m != nil {
		return m.Security
	}
	return nil
}

// PrometheusMixerAdapterConfig is described in istio.io documentation.
type PrometheusMixerAdapterConfig struct {
	Enabled               bool               `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	MetricsExpiryDuration *duration.Duration `protobuf:"bytes,2,opt,name=metricsExpiryDuration,proto3" json:"metricsExpiryDuration,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}           `json:"-"`
	XXX_unrecognized      []byte             `json:"-"`
	XXX_sizecache         int32              `json:"-"`
}

func (m *PrometheusMixerAdapterConfig) Reset()         { *m = PrometheusMixerAdapterConfig{} }
func (m *PrometheusMixerAdapterConfig) String() string { return proto.CompactTextString(m) }
func (*PrometheusMixerAdapterConfig) ProtoMessage()    {}
func (*PrometheusMixerAdapterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{37}
}
func (m *PrometheusMixerAdapterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrometheusMixerAdapterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrometheusMixerAdapterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrometheusMixerAdapterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrometheusMixerAdapterConfig.Merge(m, src)
}
func (m *PrometheusMixerAdapterConfig) XXX_Size() int {
	return m.Size()
}
func (m *PrometheusMixerAdapterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PrometheusMixerAdapterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PrometheusMixerAdapterConfig proto.InternalMessageInfo

func (m *PrometheusMixerAdapterConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *PrometheusMixerAdapterConfig) GetMetricsExpiryDuration() *duration.Duration {
	if m != nil {
		return m.MetricsExpiryDuration
	}
	return nil
}

// PrometheusSecurityConfig is described in istio.io documentation.
type PrometheusSecurityConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrometheusSecurityConfig) Reset()         { *m = PrometheusSecurityConfig{} }
func (m *PrometheusSecurityConfig) String() string { return proto.CompactTextString(m) }
func (*PrometheusSecurityConfig) ProtoMessage()    {}
func (*PrometheusSecurityConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{38}
}
func (m *PrometheusSecurityConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrometheusSecurityConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrometheusSecurityConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrometheusSecurityConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrometheusSecurityConfig.Merge(m, src)
}
func (m *PrometheusSecurityConfig) XXX_Size() int {
	return m.Size()
}
func (m *PrometheusSecurityConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PrometheusSecurityConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PrometheusSecurityConfig proto.InternalMessageInfo

func (m *PrometheusSecurityConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// PrometheusServiceConfig is described in istio.io documentation.
type PrometheusServiceConfig struct {
	// 	Annotations map[string]interface{}           `json:"annotations,omitempty"`
	NodePort             *PrometheusServiceNodePortConfig `protobuf:"bytes,1,opt,name=nodePort,proto3" json:"nodePort,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *PrometheusServiceConfig) Reset()         { *m = PrometheusServiceConfig{} }
func (m *PrometheusServiceConfig) String() string { return proto.CompactTextString(m) }
func (*PrometheusServiceConfig) ProtoMessage()    {}
func (*PrometheusServiceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{39}
}
func (m *PrometheusServiceConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrometheusServiceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrometheusServiceConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrometheusServiceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrometheusServiceConfig.Merge(m, src)
}
func (m *PrometheusServiceConfig) XXX_Size() int {
	return m.Size()
}
func (m *PrometheusServiceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PrometheusServiceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PrometheusServiceConfig proto.InternalMessageInfo

func (m *PrometheusServiceConfig) GetNodePort() *PrometheusServiceNodePortConfig {
	if m != nil {
		return m.NodePort
	}
	return nil
}

// PrometheusServiceNodePortConfig is described in istio.io documentation.
type PrometheusServiceNodePortConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Port                 uint32   `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrometheusServiceNodePortConfig) Reset()         { *m = PrometheusServiceNodePortConfig{} }
func (m *PrometheusServiceNodePortConfig) String() string { return proto.CompactTextString(m) }
func (*PrometheusServiceNodePortConfig) ProtoMessage()    {}
func (*PrometheusServiceNodePortConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{40}
}
func (m *PrometheusServiceNodePortConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrometheusServiceNodePortConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrometheusServiceNodePortConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrometheusServiceNodePortConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrometheusServiceNodePortConfig.Merge(m, src)
}
func (m *PrometheusServiceNodePortConfig) XXX_Size() int {
	return m.Size()
}
func (m *PrometheusServiceNodePortConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PrometheusServiceNodePortConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PrometheusServiceNodePortConfig proto.InternalMessageInfo

func (m *PrometheusServiceNodePortConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *PrometheusServiceNodePortConfig) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// ProxyConfig specifies how proxies are configured within Istio.
type ProxyConfig struct {
	// Specifies the path to write the sidecar access log file.
	AccessLogFile string `protobuf:"bytes,1,opt,name=accessLogFile,proto3" json:"accessLogFile,omitempty"`
	// Configures how and what fields are displayed in sidecar access log.
	AccessLogFormat string `protobuf:"bytes,2,opt,name=accessLogFormat,proto3" json:"accessLogFormat,omitempty"`
	// Domain for the cluster - defaults to .cluster.local, but k8s allows this to be customized, can be prod.example.com
	ClusterDomain     string `protobuf:"bytes,5,opt,name=clusterDomain,proto3" json:"clusterDomain,omitempty"`
	ComponentLogLevel string `protobuf:"bytes,6,opt,name=componentLogLevel,proto3" json:"componentLogLevel,omitempty"`
	// Controls number of proxy worker threads.
	Concurrency uint32 `protobuf:"varint,7,opt,name=concurrency,proto3" json:"concurrency,omitempty"`
	// Configures the DNS refresh rate for Envoy cluster of type STRICT_DNS.
	DnsRefreshRate *duration.Duration `protobuf:"bytes,8,opt,name=dnsRefreshRate,proto3" json:"dnsRefreshRate,omitempty"`
	// Enables core dumps for newly injected sidecars.
	EnableCoreDump      bool                `protobuf:"varint,9,opt,name=enableCoreDump,proto3" json:"enableCoreDump,omitempty"`
	EnvoyMetricsService *EnvoyMetricsConfig `protobuf:"bytes,10,opt,name=envoyMetricsService,proto3" json:"envoyMetricsService,omitempty"`
	EnvoyStatsd         *EnvoyMetricsConfig `protobuf:"bytes,11,opt,name=envoyStatsd,proto3" json:"envoyStatsd,omitempty"`
	// Specifies the Istio ingress ports not to capture.
	ExcludeInboundPorts string `protobuf:"bytes,12,opt,name=excludeInboundPorts,proto3" json:"excludeInboundPorts,omitempty"`
	// Lists the excluded IP ranges of Istio egress traffic that the sidecar captures.
	ExcludeIPRanges string `protobuf:"bytes,13,opt,name=excludeIPRanges,proto3" json:"excludeIPRanges,omitempty"`
	// Image name or path for the proxy.
	Image string `protobuf:"bytes,14,opt,name=image,proto3" json:"image,omitempty"`
	// Specifies the Istio ingress ports to capture.
	IncludeInboundPorts string `protobuf:"bytes,15,opt,name=includeInboundPorts,proto3" json:"includeInboundPorts,omitempty"`
	// Lists the IP ranges of Istio egress traffic that the sidecar captures.
	IncludeIPRanges    string `protobuf:"bytes,16,opt,name=includeIPRanges,proto3" json:"includeIPRanges,omitempty"`
	KubevirtInterfaces string `protobuf:"bytes,17,opt,name=kubevirtInterfaces,proto3" json:"kubevirtInterfaces,omitempty"`
	LogLevel           string `protobuf:"bytes,18,opt,name=logLevel,proto3" json:"logLevel,omitempty"`
	Privileged         bool   `protobuf:"varint,19,opt,name=privileged,proto3" json:"privileged,omitempty"`
	// Sets the initial delay for readiness probes in seconds.
	ReadinessInitialDelaySeconds uint32 `protobuf:"varint,20,opt,name=readinessInitialDelaySeconds,proto3" json:"readinessInitialDelaySeconds,omitempty"`
	// Sets the interval between readiness probes in seconds.
	ReadinessPeriodSeconds uint32 `protobuf:"varint,21,opt,name=readinessPeriodSeconds,proto3" json:"readinessPeriodSeconds,omitempty"`
	// Sets the number of successive failed probes before indicating readiness failure.
	ReadinessFailureThreshold uint32 `protobuf:"varint,22,opt,name=readinessFailureThreshold,proto3" json:"readinessFailureThreshold,omitempty"`
	// Default port used for the Pilot agent's health checks.
	StatusPort           uint32                   `protobuf:"varint,23,opt,name=statusPort,proto3" json:"statusPort,omitempty"`
	Resources            *v1.ResourceRequirements `protobuf:"bytes,24,opt,name=resources,proto3" json:"resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ProxyConfig) Reset()         { *m = ProxyConfig{} }
func (m *ProxyConfig) String() string { return proto.CompactTextString(m) }
func (*ProxyConfig) ProtoMessage()    {}
func (*ProxyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{41}
}
func (m *ProxyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyConfig.Merge(m, src)
}
func (m *ProxyConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProxyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyConfig proto.InternalMessageInfo

func (m *ProxyConfig) GetAccessLogFile() string {
	if m != nil {
		return m.AccessLogFile
	}
	return ""
}

func (m *ProxyConfig) GetAccessLogFormat() string {
	if m != nil {
		return m.AccessLogFormat
	}
	return ""
}

func (m *ProxyConfig) GetClusterDomain() string {
	if m != nil {
		return m.ClusterDomain
	}
	return ""
}

func (m *ProxyConfig) GetComponentLogLevel() string {
	if m != nil {
		return m.ComponentLogLevel
	}
	return ""
}

func (m *ProxyConfig) GetConcurrency() uint32 {
	if m != nil {
		return m.Concurrency
	}
	return 0
}

func (m *ProxyConfig) GetDnsRefreshRate() *duration.Duration {
	if m != nil {
		return m.DnsRefreshRate
	}
	return nil
}

func (m *ProxyConfig) GetEnableCoreDump() bool {
	if m != nil {
		return m.EnableCoreDump
	}
	return false
}

func (m *ProxyConfig) GetEnvoyMetricsService() *EnvoyMetricsConfig {
	if m != nil {
		return m.EnvoyMetricsService
	}
	return nil
}

func (m *ProxyConfig) GetEnvoyStatsd() *EnvoyMetricsConfig {
	if m != nil {
		return m.EnvoyStatsd
	}
	return nil
}

func (m *ProxyConfig) GetExcludeInboundPorts() string {
	if m != nil {
		return m.ExcludeInboundPorts
	}
	return ""
}

func (m *ProxyConfig) GetExcludeIPRanges() string {
	if m != nil {
		return m.ExcludeIPRanges
	}
	return ""
}

func (m *ProxyConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ProxyConfig) GetIncludeInboundPorts() string {
	if m != nil {
		return m.IncludeInboundPorts
	}
	return ""
}

func (m *ProxyConfig) GetIncludeIPRanges() string {
	if m != nil {
		return m.IncludeIPRanges
	}
	return ""
}

func (m *ProxyConfig) GetKubevirtInterfaces() string {
	if m != nil {
		return m.KubevirtInterfaces
	}
	return ""
}

func (m *ProxyConfig) GetLogLevel() string {
	if m != nil {
		return m.LogLevel
	}
	return ""
}

func (m *ProxyConfig) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *ProxyConfig) GetReadinessInitialDelaySeconds() uint32 {
	if m != nil {
		return m.ReadinessInitialDelaySeconds
	}
	return 0
}

func (m *ProxyConfig) GetReadinessPeriodSeconds() uint32 {
	if m != nil {
		return m.ReadinessPeriodSeconds
	}
	return 0
}

func (m *ProxyConfig) GetReadinessFailureThreshold() uint32 {
	if m != nil {
		return m.ReadinessFailureThreshold
	}
	return 0
}

func (m *ProxyConfig) GetStatusPort() uint32 {
	if m != nil {
		return m.StatusPort
	}
	return 0
}

func (m *ProxyConfig) GetResources() *v1.ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

// ProxyInitConfig is described in istio.io documentation.
type ProxyInitConfig struct {
	Image                string   `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProxyInitConfig) Reset()         { *m = ProxyInitConfig{} }
func (m *ProxyInitConfig) String() string { return proto.CompactTextString(m) }
func (*ProxyInitConfig) ProtoMessage()    {}
func (*ProxyInitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{42}
}
func (m *ProxyInitConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyInitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyInitConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyInitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyInitConfig.Merge(m, src)
}
func (m *ProxyInitConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProxyInitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyInitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyInitConfig proto.InternalMessageInfo

func (m *ProxyInitConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

// ResourcesRequestsConfig is described in istio.io documentation.
type ResourcesRequestsConfig struct {
	Cpu                  string   `protobuf:"bytes,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Memory               string   `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourcesRequestsConfig) Reset()         { *m = ResourcesRequestsConfig{} }
func (m *ResourcesRequestsConfig) String() string { return proto.CompactTextString(m) }
func (*ResourcesRequestsConfig) ProtoMessage()    {}
func (*ResourcesRequestsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{43}
}
func (m *ResourcesRequestsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcesRequestsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcesRequestsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcesRequestsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcesRequestsConfig.Merge(m, src)
}
func (m *ResourcesRequestsConfig) XXX_Size() int {
	return m.Size()
}
func (m *ResourcesRequestsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcesRequestsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcesRequestsConfig proto.InternalMessageInfo

func (m *ResourcesRequestsConfig) GetCpu() string {
	if m != nil {
		return m.Cpu
	}
	return ""
}

func (m *ResourcesRequestsConfig) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

// SDSConfig is described in istio.io documentation.
type SDSConfig struct {
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Specifies the Unix Domain Socket through which Envoy communicates with NodeAgent SDS to get key/cert for mTLS.
	UdsPath string `protobuf:"bytes,2,opt,name=udsPath,proto3" json:"udsPath,omitempty"`
	// Enables SDS use of k8s sa normal JWT to request for certificates.
	UseNormalJwt bool `protobuf:"varint,3,opt,name=useNormalJwt,proto3" json:"useNormalJwt,omitempty"`
	// Enables SDS use of trustworthy JWT to request for certificates.
	UseTrustworthyJwt    bool     `protobuf:"varint,4,opt,name=useTrustworthyJwt,proto3" json:"useTrustworthyJwt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SDSConfig) Reset()         { *m = SDSConfig{} }
func (m *SDSConfig) String() string { return proto.CompactTextString(m) }
func (*SDSConfig) ProtoMessage()    {}
func (*SDSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{44}
}
func (m *SDSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SDSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SDSConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SDSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SDSConfig.Merge(m, src)
}
func (m *SDSConfig) XXX_Size() int {
	return m.Size()
}
func (m *SDSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SDSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SDSConfig proto.InternalMessageInfo

func (m *SDSConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *SDSConfig) GetUdsPath() string {
	if m != nil {
		return m.UdsPath
	}
	return ""
}

func (m *SDSConfig) GetUseNormalJwt() bool {
	if m != nil {
		return m.UseNormalJwt
	}
	return false
}

func (m *SDSConfig) GetUseTrustworthyJwt() bool {
	if m != nil {
		return m.UseTrustworthyJwt
	}
	return false
}

// SecretVolume is described in istio.io documentation.
type SecretVolume struct {
	MountPath            string   `protobuf:"bytes,1,opt,name=mountPath,proto3" json:"mountPath,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	SecretName           string   `protobuf:"bytes,3,opt,name=secretName,proto3" json:"secretName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecretVolume) Reset()         { *m = SecretVolume{} }
func (m *SecretVolume) String() string { return proto.CompactTextString(m) }
func (*SecretVolume) ProtoMessage()    {}
func (*SecretVolume) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{45}
}
func (m *SecretVolume) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretVolume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecretVolume.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecretVolume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretVolume.Merge(m, src)
}
func (m *SecretVolume) XXX_Size() int {
	return m.Size()
}
func (m *SecretVolume) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretVolume.DiscardUnknown(m)
}

var xxx_messageInfo_SecretVolume proto.InternalMessageInfo

func (m *SecretVolume) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *SecretVolume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SecretVolume) GetSecretName() string {
	if m != nil {
		return m.SecretName
	}
	return ""
}

// SecurityConfig is described in istio.io documentation.
type SecurityConfig struct {
	Enabled              bool              `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	ReplicaCount         uint32            `protobuf:"varint,2,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	Image                string            `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	SelfSigned           bool              `protobuf:"varint,4,opt,name=selfSigned,proto3" json:"selfSigned,omitempty"`
	TrustDomain          string            `protobuf:"bytes,5,opt,name=trustDomain,proto3" json:"trustDomain,omitempty"`
	DnsCerts             map[string]string `protobuf:"bytes,6,rep,name=dnsCerts,proto3" json:"dnsCerts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CreateMeshPolicy     bool              `protobuf:"varint,7,opt,name=createMeshPolicy,proto3" json:"createMeshPolicy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SecurityConfig) Reset()         { *m = SecurityConfig{} }
func (m *SecurityConfig) String() string { return proto.CompactTextString(m) }
func (*SecurityConfig) ProtoMessage()    {}
func (*SecurityConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{46}
}
func (m *SecurityConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityConfig.Merge(m, src)
}
func (m *SecurityConfig) XXX_Size() int {
	return m.Size()
}
func (m *SecurityConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityConfig proto.InternalMessageInfo

func (m *SecurityConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *SecurityConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *SecurityConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *SecurityConfig) GetSelfSigned() bool {
	if m != nil {
		return m.SelfSigned
	}
	return false
}

func (m *SecurityConfig) GetTrustDomain() string {
	if m != nil {
		return m.TrustDomain
	}
	return ""
}

func (m *SecurityConfig) GetDnsCerts() map[string]string {
	if m != nil {
		return m.DnsCerts
	}
	return nil
}

func (m *SecurityConfig) GetCreateMeshPolicy() bool {
	if m != nil {
		return m.CreateMeshPolicy
	}
	return false
}

// ServiceConfig is described in istio.io documentation.
type ServiceConfig struct {
	// 	Annotations  map[string]interface{} `json:"annotations,omitempty"`
	ExternalPort         uint32   `protobuf:"varint,1,opt,name=externalPort,proto3" json:"externalPort,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceConfig) Reset()         { *m = ServiceConfig{} }
func (m *ServiceConfig) String() string { return proto.CompactTextString(m) }
func (*ServiceConfig) ProtoMessage()    {}
func (*ServiceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{47}
}
func (m *ServiceConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceConfig.Merge(m, src)
}
func (m *ServiceConfig) XXX_Size() int {
	return m.Size()
}
func (m *ServiceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceConfig proto.InternalMessageInfo

func (m *ServiceConfig) GetExternalPort() uint32 {
	if m != nil {
		return m.ExternalPort
	}
	return 0
}

func (m *ServiceConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// SidecarInjectorConfig is described in istio.io documentation.
type SidecarInjectorConfig struct {
	// 	AlwaysInjectSelector             []map[string]interface{} `json:"alwaysInjectSelector,omitempty"`
	Enabled                   bool   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	EnableNamespacesByDefault bool   `protobuf:"varint,2,opt,name=enableNamespacesByDefault,proto3" json:"enableNamespacesByDefault,omitempty"`
	Image                     string `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	// 	NodeSelector                     map[string]interface{}   `json:"nodeSelector,omitempty"`
	// 	NeverInjectSelector              []map[string]interface{} `json:"neverInjectSelector,omitempty"`
	// 	PodAntiAffinityLabelSelector     []map[string]interface{} `json:"podAntiAffinityLabelSelector"`
	// 	PodAntiAffinityTermLabelSelector []map[string]interface{} `json:"podAntiAffinityTermLabelSelector"`
	ReplicaCount         uint32   `protobuf:"varint,4,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	RewriteAppHTTPProbe  bool     `protobuf:"varint,5,opt,name=rewriteAppHTTPProbe,proto3" json:"rewriteAppHTTPProbe,omitempty"`
	SelfSigned           bool     `protobuf:"varint,6,opt,name=selfSigned,proto3" json:"selfSigned,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SidecarInjectorConfig) Reset()         { *m = SidecarInjectorConfig{} }
func (m *SidecarInjectorConfig) String() string { return proto.CompactTextString(m) }
func (*SidecarInjectorConfig) ProtoMessage()    {}
func (*SidecarInjectorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{48}
}
func (m *SidecarInjectorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SidecarInjectorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SidecarInjectorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SidecarInjectorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SidecarInjectorConfig.Merge(m, src)
}
func (m *SidecarInjectorConfig) XXX_Size() int {
	return m.Size()
}
func (m *SidecarInjectorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SidecarInjectorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SidecarInjectorConfig proto.InternalMessageInfo

func (m *SidecarInjectorConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *SidecarInjectorConfig) GetEnableNamespacesByDefault() bool {
	if m != nil {
		return m.EnableNamespacesByDefault
	}
	return false
}

func (m *SidecarInjectorConfig) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *SidecarInjectorConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *SidecarInjectorConfig) GetRewriteAppHTTPProbe() bool {
	if m != nil {
		return m.RewriteAppHTTPProbe
	}
	return false
}

func (m *SidecarInjectorConfig) GetSelfSigned() bool {
	if m != nil {
		return m.SelfSigned
	}
	return false
}

// StdioMixerAdapterConfig is described in istio.io documentation.
type StdioMixerAdapterConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	OutputAsJson         bool     `protobuf:"varint,2,opt,name=outputAsJson,proto3" json:"outputAsJson,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StdioMixerAdapterConfig) Reset()         { *m = StdioMixerAdapterConfig{} }
func (m *StdioMixerAdapterConfig) String() string { return proto.CompactTextString(m) }
func (*StdioMixerAdapterConfig) ProtoMessage()    {}
func (*StdioMixerAdapterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{49}
}
func (m *StdioMixerAdapterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StdioMixerAdapterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StdioMixerAdapterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StdioMixerAdapterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StdioMixerAdapterConfig.Merge(m, src)
}
func (m *StdioMixerAdapterConfig) XXX_Size() int {
	return m.Size()
}
func (m *StdioMixerAdapterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StdioMixerAdapterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StdioMixerAdapterConfig proto.InternalMessageInfo

func (m *StdioMixerAdapterConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *StdioMixerAdapterConfig) GetOutputAsJson() bool {
	if m != nil {
		return m.OutputAsJson
	}
	return false
}

// TracerConfig is described in istio.io documentation.
type TracerConfig struct {
	Datadog              *TracerDatadogConfig   `protobuf:"bytes,1,opt,name=datadog,proto3" json:"datadog,omitempty"`
	Lightstep            *TracerLightStepConfig `protobuf:"bytes,2,opt,name=lightstep,proto3" json:"lightstep,omitempty"`
	Zipkin               *TracerZipkinConfig    `protobuf:"bytes,3,opt,name=zipkin,proto3" json:"zipkin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TracerConfig) Reset()         { *m = TracerConfig{} }
func (m *TracerConfig) String() string { return proto.CompactTextString(m) }
func (*TracerConfig) ProtoMessage()    {}
func (*TracerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{50}
}
func (m *TracerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracerConfig.Merge(m, src)
}
func (m *TracerConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracerConfig proto.InternalMessageInfo

func (m *TracerConfig) GetDatadog() *TracerDatadogConfig {
	if m != nil {
		return m.Datadog
	}
	return nil
}

func (m *TracerConfig) GetLightstep() *TracerLightStepConfig {
	if m != nil {
		return m.Lightstep
	}
	return nil
}

func (m *TracerConfig) GetZipkin() *TracerZipkinConfig {
	if m != nil {
		return m.Zipkin
	}
	return nil
}

// TracerDatadogConfig is described in istio.io documentation.
type TracerDatadogConfig struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TracerDatadogConfig) Reset()         { *m = TracerDatadogConfig{} }
func (m *TracerDatadogConfig) String() string { return proto.CompactTextString(m) }
func (*TracerDatadogConfig) ProtoMessage()    {}
func (*TracerDatadogConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{51}
}
func (m *TracerDatadogConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracerDatadogConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracerDatadogConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracerDatadogConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracerDatadogConfig.Merge(m, src)
}
func (m *TracerDatadogConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracerDatadogConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracerDatadogConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracerDatadogConfig proto.InternalMessageInfo

func (m *TracerDatadogConfig) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// TracerLightStepConfig is described in istio.io documentation.
type TracerLightStepConfig struct {
	// Sets the lightstep satellite pool address.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Sets the lightstep access token.
	AccessToken string `protobuf:"bytes,2,opt,name=accessToken,proto3" json:"accessToken,omitempty"`
	// Sets path to the file containing the cacert to use when verifying TLS.
	CacertPath string `protobuf:"bytes,3,opt,name=cacertPath,proto3" json:"cacertPath,omitempty"`
	// Enables lightstep secure connection.
	Secure               bool     `protobuf:"varint,4,opt,name=secure,proto3" json:"secure,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TracerLightStepConfig) Reset()         { *m = TracerLightStepConfig{} }
func (m *TracerLightStepConfig) String() string { return proto.CompactTextString(m) }
func (*TracerLightStepConfig) ProtoMessage()    {}
func (*TracerLightStepConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{52}
}
func (m *TracerLightStepConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracerLightStepConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracerLightStepConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracerLightStepConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracerLightStepConfig.Merge(m, src)
}
func (m *TracerLightStepConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracerLightStepConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracerLightStepConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracerLightStepConfig proto.InternalMessageInfo

func (m *TracerLightStepConfig) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *TracerLightStepConfig) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *TracerLightStepConfig) GetCacertPath() string {
	if m != nil {
		return m.CacertPath
	}
	return ""
}

func (m *TracerLightStepConfig) GetSecure() bool {
	if m != nil {
		return m.Secure
	}
	return false
}

// TracerZipkinConfig is described in istio.io documentation.
type TracerZipkinConfig struct {
	// Specifies address in host:port format for reporting trace data in zipkin format.
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TracerZipkinConfig) Reset()         { *m = TracerZipkinConfig{} }
func (m *TracerZipkinConfig) String() string { return proto.CompactTextString(m) }
func (*TracerZipkinConfig) ProtoMessage()    {}
func (*TracerZipkinConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{53}
}
func (m *TracerZipkinConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracerZipkinConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracerZipkinConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracerZipkinConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracerZipkinConfig.Merge(m, src)
}
func (m *TracerZipkinConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracerZipkinConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracerZipkinConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracerZipkinConfig proto.InternalMessageInfo

func (m *TracerZipkinConfig) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// TracingConfig is described in istio.io documentation.
type TracingConfig struct {
	Enabled bool                  `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Ingress *TracingIngressConfig `protobuf:"bytes,2,opt,name=ingress,proto3" json:"ingress,omitempty"`
	Jaeger  *TracingJaegerConfig  `protobuf:"bytes,3,opt,name=jaeger,proto3" json:"jaeger,omitempty"`
	// 	NodeSelector map[string]interface{} `json:"nodeSelector,omitempty"`
	Provider             string               `protobuf:"bytes,4,opt,name=provider,proto3" json:"provider,omitempty"`
	Service              *ServiceConfig       `protobuf:"bytes,5,opt,name=service,proto3" json:"service,omitempty"`
	Zipkin               *TracingZipkinConfig `protobuf:"bytes,6,opt,name=zipkin,proto3" json:"zipkin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TracingConfig) Reset()         { *m = TracingConfig{} }
func (m *TracingConfig) String() string { return proto.CompactTextString(m) }
func (*TracingConfig) ProtoMessage()    {}
func (*TracingConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{54}
}
func (m *TracingConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracingConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracingConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracingConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracingConfig.Merge(m, src)
}
func (m *TracingConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracingConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracingConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracingConfig proto.InternalMessageInfo

func (m *TracingConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *TracingConfig) GetIngress() *TracingIngressConfig {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *TracingConfig) GetJaeger() *TracingJaegerConfig {
	if m != nil {
		return m.Jaeger
	}
	return nil
}

func (m *TracingConfig) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *TracingConfig) GetService() *ServiceConfig {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *TracingConfig) GetZipkin() *TracingZipkinConfig {
	if m != nil {
		return m.Zipkin
	}
	return nil
}

// TracingIngressConfig is described in istio.io documentation.
type TracingIngressConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TracingIngressConfig) Reset()         { *m = TracingIngressConfig{} }
func (m *TracingIngressConfig) String() string { return proto.CompactTextString(m) }
func (*TracingIngressConfig) ProtoMessage()    {}
func (*TracingIngressConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{55}
}
func (m *TracingIngressConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracingIngressConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracingIngressConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracingIngressConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracingIngressConfig.Merge(m, src)
}
func (m *TracingIngressConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracingIngressConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracingIngressConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracingIngressConfig proto.InternalMessageInfo

func (m *TracingIngressConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// TracingJaegerConfig is described in istio.io documentation.
type TracingJaegerConfig struct {
	Hub                  string                     `protobuf:"bytes,1,opt,name=hub,proto3" json:"hub,omitempty"`
	Tag                  string                     `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
	Memory               *TracingJaegerMemoryConfig `protobuf:"bytes,3,opt,name=memory,proto3" json:"memory,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TracingJaegerConfig) Reset()         { *m = TracingJaegerConfig{} }
func (m *TracingJaegerConfig) String() string { return proto.CompactTextString(m) }
func (*TracingJaegerConfig) ProtoMessage()    {}
func (*TracingJaegerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{56}
}
func (m *TracingJaegerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracingJaegerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracingJaegerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracingJaegerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracingJaegerConfig.Merge(m, src)
}
func (m *TracingJaegerConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracingJaegerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracingJaegerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracingJaegerConfig proto.InternalMessageInfo

func (m *TracingJaegerConfig) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *TracingJaegerConfig) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *TracingJaegerConfig) GetMemory() *TracingJaegerMemoryConfig {
	if m != nil {
		return m.Memory
	}
	return nil
}

// TracingJaegerMemoryConfig is described in istio.io documentation.
type TracingJaegerMemoryConfig struct {
	MaxTraces            uint32   `protobuf:"varint,1,opt,name=max_traces,json=maxTraces,proto3" json:"max_traces,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TracingJaegerMemoryConfig) Reset()         { *m = TracingJaegerMemoryConfig{} }
func (m *TracingJaegerMemoryConfig) String() string { return proto.CompactTextString(m) }
func (*TracingJaegerMemoryConfig) ProtoMessage()    {}
func (*TracingJaegerMemoryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{57}
}
func (m *TracingJaegerMemoryConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracingJaegerMemoryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracingJaegerMemoryConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracingJaegerMemoryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracingJaegerMemoryConfig.Merge(m, src)
}
func (m *TracingJaegerMemoryConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracingJaegerMemoryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracingJaegerMemoryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracingJaegerMemoryConfig proto.InternalMessageInfo

func (m *TracingJaegerMemoryConfig) GetMaxTraces() uint32 {
	if m != nil {
		return m.MaxTraces
	}
	return 0
}

// TracingZipkinConfig is described in istio.io documentation.
type TracingZipkinConfig struct {
	Hub                  string                   `protobuf:"bytes,1,opt,name=hub,proto3" json:"hub,omitempty"`
	Tag                  string                   `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
	ProbeStartupDelay    uint32                   `protobuf:"varint,3,opt,name=probeStartupDelay,proto3" json:"probeStartupDelay,omitempty"`
	QueryPort            uint32                   `protobuf:"varint,4,opt,name=queryPort,proto3" json:"queryPort,omitempty"`
	Resources            *v1.ResourceRequirements `protobuf:"bytes,5,opt,name=resources,proto3" json:"resources,omitempty"`
	JavaOptsHeap         string                   `protobuf:"bytes,6,opt,name=javaOptsHeap,proto3" json:"javaOptsHeap,omitempty"`
	MaxSpans             uint32                   `protobuf:"varint,7,opt,name=maxSpans,proto3" json:"maxSpans,omitempty"`
	Node                 *TracingZipkinNodeConfig `protobuf:"bytes,8,opt,name=node,proto3" json:"node,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TracingZipkinConfig) Reset()         { *m = TracingZipkinConfig{} }
func (m *TracingZipkinConfig) String() string { return proto.CompactTextString(m) }
func (*TracingZipkinConfig) ProtoMessage()    {}
func (*TracingZipkinConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{58}
}
func (m *TracingZipkinConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracingZipkinConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracingZipkinConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracingZipkinConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracingZipkinConfig.Merge(m, src)
}
func (m *TracingZipkinConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracingZipkinConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracingZipkinConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracingZipkinConfig proto.InternalMessageInfo

func (m *TracingZipkinConfig) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *TracingZipkinConfig) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *TracingZipkinConfig) GetProbeStartupDelay() uint32 {
	if m != nil {
		return m.ProbeStartupDelay
	}
	return 0
}

func (m *TracingZipkinConfig) GetQueryPort() uint32 {
	if m != nil {
		return m.QueryPort
	}
	return 0
}

func (m *TracingZipkinConfig) GetResources() *v1.ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *TracingZipkinConfig) GetJavaOptsHeap() string {
	if m != nil {
		return m.JavaOptsHeap
	}
	return ""
}

func (m *TracingZipkinConfig) GetMaxSpans() uint32 {
	if m != nil {
		return m.MaxSpans
	}
	return 0
}

func (m *TracingZipkinConfig) GetNode() *TracingZipkinNodeConfig {
	if m != nil {
		return m.Node
	}
	return nil
}

// TracingZipkinNodeConfig is described in istio.io documentation.
type TracingZipkinNodeConfig struct {
	Cpus                 uint32   `protobuf:"varint,1,opt,name=cpus,proto3" json:"cpus,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TracingZipkinNodeConfig) Reset()         { *m = TracingZipkinNodeConfig{} }
func (m *TracingZipkinNodeConfig) String() string { return proto.CompactTextString(m) }
func (*TracingZipkinNodeConfig) ProtoMessage()    {}
func (*TracingZipkinNodeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{59}
}
func (m *TracingZipkinNodeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracingZipkinNodeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracingZipkinNodeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracingZipkinNodeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracingZipkinNodeConfig.Merge(m, src)
}
func (m *TracingZipkinNodeConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracingZipkinNodeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracingZipkinNodeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracingZipkinNodeConfig proto.InternalMessageInfo

func (m *TracingZipkinNodeConfig) GetCpus() uint32 {
	if m != nil {
		return m.Cpus
	}
	return 0
}

type Values struct {
	Certmanager  *CertManagerConfig `protobuf:"bytes,1,opt,name=certmanager,proto3" json:"certmanager,omitempty"`
	IstioCni     *CNIConfig         `protobuf:"bytes,2,opt,name=istio_cni,json=istioCni,proto3" json:"istio_cni,omitempty"`
	Istiocoredns *CoreDNSConfig     `protobuf:"bytes,3,opt,name=istiocoredns,proto3" json:"istiocoredns,omitempty"`
	Galley       *GalleyConfig      `protobuf:"bytes,4,opt,name=galley,proto3" json:"galley,omitempty"`
	Gateways     *GatewaysConfig    `protobuf:"bytes,5,opt,name=gateways,proto3" json:"gateways,omitempty"`
	Global       *GlobalConfig      `protobuf:"bytes,6,opt,name=global,proto3" json:"global,omitempty"`
	// 	Grafana         map[string]interface{} `json:"grafana,omitempty"`
	Mixer                  *MixerConfig           `protobuf:"bytes,7,opt,name=mixer,proto3" json:"mixer,omitempty"`
	Nodeagent              *NodeAgentConfig       `protobuf:"bytes,8,opt,name=nodeagent,proto3" json:"nodeagent,omitempty"`
	Pilot                  *PilotConfig           `protobuf:"bytes,9,opt,name=pilot,proto3" json:"pilot,omitempty"`
	Prometheus             *PrometheusConfig      `protobuf:"bytes,10,opt,name=prometheus,proto3" json:"prometheus,omitempty"`
	Security               *SecurityConfig        `protobuf:"bytes,11,opt,name=security,proto3" json:"security,omitempty"`
	SidecarInjectorWebhook *SidecarInjectorConfig `protobuf:"bytes,12,opt,name=sidecarInjectorWebhook,proto3" json:"sidecarInjectorWebhook,omitempty"`
	Tracing                *TracingConfig         `protobuf:"bytes,13,opt,name=tracing,proto3" json:"tracing,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}               `json:"-"`
	XXX_unrecognized       []byte                 `json:"-"`
	XXX_sizecache          int32                  `json:"-"`
}

func (m *Values) Reset()         { *m = Values{} }
func (m *Values) String() string { return proto.CompactTextString(m) }
func (*Values) ProtoMessage()    {}
func (*Values) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{60}
}
func (m *Values) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Values) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Values.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Values) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Values.Merge(m, src)
}
func (m *Values) XXX_Size() int {
	return m.Size()
}
func (m *Values) XXX_DiscardUnknown() {
	xxx_messageInfo_Values.DiscardUnknown(m)
}

var xxx_messageInfo_Values proto.InternalMessageInfo

func (m *Values) GetCertmanager() *CertManagerConfig {
	if m != nil {
		return m.Certmanager
	}
	return nil
}

func (m *Values) GetIstioCni() *CNIConfig {
	if m != nil {
		return m.IstioCni
	}
	return nil
}

func (m *Values) GetIstiocoredns() *CoreDNSConfig {
	if m != nil {
		return m.Istiocoredns
	}
	return nil
}

func (m *Values) GetGalley() *GalleyConfig {
	if m != nil {
		return m.Galley
	}
	return nil
}

func (m *Values) GetGateways() *GatewaysConfig {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *Values) GetGlobal() *GlobalConfig {
	if m != nil {
		return m.Global
	}
	return nil
}

func (m *Values) GetMixer() *MixerConfig {
	if m != nil {
		return m.Mixer
	}
	return nil
}

func (m *Values) GetNodeagent() *NodeAgentConfig {
	if m != nil {
		return m.Nodeagent
	}
	return nil
}

func (m *Values) GetPilot() *PilotConfig {
	if m != nil {
		return m.Pilot
	}
	return nil
}

func (m *Values) GetPrometheus() *PrometheusConfig {
	if m != nil {
		return m.Prometheus
	}
	return nil
}

func (m *Values) GetSecurity() *SecurityConfig {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *Values) GetSidecarInjectorWebhook() *SidecarInjectorConfig {
	if m != nil {
		return m.SidecarInjectorWebhook
	}
	return nil
}

func (m *Values) GetTracing() *TracingConfig {
	if m != nil {
		return m.Tracing
	}
	return nil
}

// ZeroVPNConfig is described in istio.io documentation.
type ZeroVPNConfig struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Suffix               string   `protobuf:"bytes,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroVPNConfig) Reset()         { *m = ZeroVPNConfig{} }
func (m *ZeroVPNConfig) String() string { return proto.CompactTextString(m) }
func (*ZeroVPNConfig) ProtoMessage()    {}
func (*ZeroVPNConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1b42944a61fb295, []int{61}
}
func (m *ZeroVPNConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroVPNConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroVPNConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroVPNConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroVPNConfig.Merge(m, src)
}
func (m *ZeroVPNConfig) XXX_Size() int {
	return m.Size()
}
func (m *ZeroVPNConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroVPNConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroVPNConfig proto.InternalMessageInfo

func (m *ZeroVPNConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *ZeroVPNConfig) GetSuffix() string {
	if m != nil {
		return m.Suffix
	}
	return ""
}

func init() {
	proto.RegisterEnum("values.LoadSheddingConfigMode", LoadSheddingConfigMode_name, LoadSheddingConfigMode_value)
	proto.RegisterEnum("values.OutboundTrafficPolicyConfigMode", OutboundTrafficPolicyConfigMode_name, OutboundTrafficPolicyConfigMode_value)
	proto.RegisterEnum("values.PilotIngressConfigIngressControllerMode", PilotIngressConfigIngressControllerMode_name, PilotIngressConfigIngressControllerMode_value)
	proto.RegisterEnum("values.ProxyConfigAccessLogEncoding", ProxyConfigAccessLogEncoding_name, ProxyConfigAccessLogEncoding_value)
	proto.RegisterEnum("values.ProxyConfigAutoInject", ProxyConfigAutoInject_name, ProxyConfigAutoInject_value)
	proto.RegisterEnum("values.ProxyConfigTracer", ProxyConfigTracer_name, ProxyConfigTracer_value)
	proto.RegisterType((*AddonIngressConfig)(nil), "values.AddonIngressConfig")
	proto.RegisterType((*ArchConfig)(nil), "values.ArchConfig")
	proto.RegisterType((*CNIConfig)(nil), "values.CNIConfig")
	proto.RegisterType((*CPUTargetUtilizationConfig)(nil), "values.CPUTargetUtilizationConfig")
	proto.RegisterType((*CertManagerConfig)(nil), "values.CertManagerConfig")
	proto.RegisterType((*CoreDNSConfig)(nil), "values.CoreDNSConfig")
	proto.RegisterType((*DefaultPodDisruptionBudgetConfig)(nil), "values.DefaultPodDisruptionBudgetConfig")
	proto.RegisterType((*DefaultResourcesConfig)(nil), "values.DefaultResourcesConfig")
	proto.RegisterType((*EgressGatewayConfig)(nil), "values.EgressGatewayConfig")
	proto.RegisterMapType((map[string]string)(nil), "values.EgressGatewayConfig.EnvEntry")
	proto.RegisterMapType((map[string]string)(nil), "values.EgressGatewayConfig.NodeSelectorEntry")
	proto.RegisterType((*EnvoyMetricsConfig)(nil), "values.EnvoyMetricsConfig")
	proto.RegisterType((*GalleyConfig)(nil), "values.GalleyConfig")
	proto.RegisterMapType((map[string]string)(nil), "values.GalleyConfig.MeshEntry")
	proto.RegisterType((*GatewayLabelsConfig)(nil), "values.GatewayLabelsConfig")
	proto.RegisterType((*GatewaysConfig)(nil), "values.GatewaysConfig")
	proto.RegisterType((*GlobalConfig)(nil), "values.GlobalConfig")
	proto.RegisterMapType((map[string]string)(nil), "values.GlobalConfig.DefaultNodeSelectorEntry")
	proto.RegisterMapType((map[string]string)(nil), "values.GlobalConfig.LocalityLbSettingEntry")
	proto.RegisterMapType((map[string]string)(nil), "values.GlobalConfig.MeshNetworksEntry")
	proto.RegisterType((*GlobalLoggingConfig)(nil), "values.GlobalLoggingConfig")
	proto.RegisterType((*ILBGatewayConfig)(nil), "values.ILBGatewayConfig")
	proto.RegisterType((*IngressGatewayConfig)(nil), "values.IngressGatewayConfig")
	proto.RegisterMapType((map[string]string)(nil), "values.IngressGatewayConfig.EnvEntry")
	proto.RegisterType((*IngressGatewaySdsConfig)(nil), "values.IngressGatewaySdsConfig")
	proto.RegisterType((*IngressGatewayZvpnConfig)(nil), "values.IngressGatewayZvpnConfig")
	proto.RegisterType((*KubernetesEnvMixerAdapterConfig)(nil), "values.KubernetesEnvMixerAdapterConfig")
	proto.RegisterType((*KubernetesIngressConfig)(nil), "values.KubernetesIngressConfig")
	proto.RegisterType((*LoadSheddingConfig)(nil), "values.LoadSheddingConfig")
	proto.RegisterType((*MTLSConfig)(nil), "values.MTLSConfig")
	proto.RegisterType((*MeshExpansionConfig)(nil), "values.MeshExpansionConfig")
	proto.RegisterType((*MixerAdaptersConfig)(nil), "values.MixerAdaptersConfig")
	proto.RegisterType((*MixerConfig)(nil), "values.MixerConfig")
	proto.RegisterMapType((map[string]string)(nil), "values.MixerConfig.EnvEntry")
	proto.RegisterType((*MixerPolicyConfig)(nil), "values.MixerPolicyConfig")
	proto.RegisterType((*MixerTelemetryConfig)(nil), "values.MixerTelemetryConfig")
	proto.RegisterMapType((map[string]string)(nil), "values.MixerTelemetryConfig.EnvEntry")
	proto.RegisterType((*MultiClusterConfig)(nil), "values.MultiClusterConfig")
	proto.RegisterType((*NodeAgentConfig)(nil), "values.NodeAgentConfig")
	proto.RegisterType((*OutboundTrafficPolicyConfig)(nil), "values.OutboundTrafficPolicyConfig")
	proto.RegisterType((*PilotConfig)(nil), "values.PilotConfig")
	proto.RegisterMapType((map[string]string)(nil), "values.PilotConfig.DeploymentLabelsEntry")
	proto.RegisterMapType((map[string]string)(nil), "values.PilotConfig.EnvEntry")
	proto.RegisterType((*PilotIngressConfig)(nil), "values.PilotIngressConfig")
	proto.RegisterType((*PilotPolicyConfig)(nil), "values.PilotPolicyConfig")
	proto.RegisterType((*PilotTelemetryConfig)(nil), "values.PilotTelemetryConfig")
	proto.RegisterType((*PortsConfig)(nil), "values.PortsConfig")
	proto.RegisterType((*PrometheusConfig)(nil), "values.PrometheusConfig")
	proto.RegisterType((*PrometheusMixerAdapterConfig)(nil), "values.PrometheusMixerAdapterConfig")
	proto.RegisterType((*PrometheusSecurityConfig)(nil), "values.PrometheusSecurityConfig")
	proto.RegisterType((*PrometheusServiceConfig)(nil), "values.PrometheusServiceConfig")
	proto.RegisterType((*PrometheusServiceNodePortConfig)(nil), "values.PrometheusServiceNodePortConfig")
	proto.RegisterType((*ProxyConfig)(nil), "values.ProxyConfig")
	proto.RegisterType((*ProxyInitConfig)(nil), "values.ProxyInitConfig")
	proto.RegisterType((*ResourcesRequestsConfig)(nil), "values.ResourcesRequestsConfig")
	proto.RegisterType((*SDSConfig)(nil), "values.SDSConfig")
	proto.RegisterType((*SecretVolume)(nil), "values.SecretVolume")
	proto.RegisterType((*SecurityConfig)(nil), "values.SecurityConfig")
	proto.RegisterMapType((map[string]string)(nil), "values.SecurityConfig.DnsCertsEntry")
	proto.RegisterType((*ServiceConfig)(nil), "values.ServiceConfig")
	proto.RegisterType((*SidecarInjectorConfig)(nil), "values.SidecarInjectorConfig")
	proto.RegisterType((*StdioMixerAdapterConfig)(nil), "values.StdioMixerAdapterConfig")
	proto.RegisterType((*TracerConfig)(nil), "values.TracerConfig")
	proto.RegisterType((*TracerDatadogConfig)(nil), "values.TracerDatadogConfig")
	proto.RegisterType((*TracerLightStepConfig)(nil), "values.TracerLightStepConfig")
	proto.RegisterType((*TracerZipkinConfig)(nil), "values.TracerZipkinConfig")
	proto.RegisterType((*TracingConfig)(nil), "values.TracingConfig")
	proto.RegisterType((*TracingIngressConfig)(nil), "values.TracingIngressConfig")
	proto.RegisterType((*TracingJaegerConfig)(nil), "values.TracingJaegerConfig")
	proto.RegisterType((*TracingJaegerMemoryConfig)(nil), "values.TracingJaegerMemoryConfig")
	proto.RegisterType((*TracingZipkinConfig)(nil), "values.TracingZipkinConfig")
	proto.RegisterType((*TracingZipkinNodeConfig)(nil), "values.TracingZipkinNodeConfig")
	proto.RegisterType((*Values)(nil), "values.Values")
	proto.RegisterType((*ZeroVPNConfig)(nil), "values.ZeroVPNConfig")
}

func init() { proto.RegisterFile("values_types.proto", fileDescriptor_c1b42944a61fb295) }

var fileDescriptor_c1b42944a61fb295 = []byte{
	// 4359 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5b, 0x4f, 0x73, 0x1b, 0x47,
	0x76, 0x37, 0x40, 0x12, 0x04, 0x1e, 0x09, 0x09, 0x6c, 0x52, 0xd4, 0x88, 0x92, 0x29, 0xed, 0xac,
	0x57, 0x96, 0x77, 0x6d, 0x48, 0x96, 0x64, 0xd9, 0x96, 0x9d, 0xf5, 0x52, 0x04, 0x45, 0x43, 0x0b,
	0x92, 0xc8, 0x00, 0xb2, 0xd7, 0x3e, 0x44, 0x69, 0xce, 0x34, 0xc1, 0x31, 0x07, 0x33, 0xa3, 0xe9,
	0x1e, 0x8a, 0xf4, 0x2d, 0xc7, 0xad, 0x54, 0xa5, 0x6a, 0x4f, 0xd9, 0xd4, 0x9e, 0x72, 0xcd, 0x07,
	0xc8, 0x07, 0x48, 0xaa, 0x52, 0xb9, 0xa4, 0x2a, 0x39, 0xe4, 0x9e, 0x72, 0x3e, 0x46, 0xaa, 0x52,
	0xa9, 0xfe, 0x33, 0x7f, 0x1a, 0x18, 0x80, 0x7f, 0xe2, 0xaa, 0xad, 0xda, 0x1b, 0xfa, 0xf5, 0x7b,
	0xdd, 0x3d, 0xaf, 0xfb, 0xbd, 0xf7, 0x7b, 0xaf, 0x1b, 0x80, 0x8e, 0xb1, 0x17, 0x13, 0xfa, 0x8a,
	0x9d, 0x86, 0x84, 0x36, 0xc3, 0x28, 0x60, 0x01, 0xaa, 0x48, 0xda, 0xda, 0xfa, 0x20, 0x08, 0x06,
	0x1e, 0xb9, 0x2f, 0xa8, 0xfb, 0xf1, 0xc1, 0x7d, 0x27, 0x8e, 0x30, 0x73, 0x03, 0x5f, 0xf2, 0xad,
	0x99, 0x47, 0x9f, 0xd0, 0xa6, 0x1b, 0xdc, 0xc7, 0xa1, 0x7b, 0xdf, 0x0e, 0x22, 0x72, 0xff, 0xf8,
	0xc3, 0xfb, 0x03, 0xe2, 0x93, 0x08, 0x33, 0xe2, 0x48, 0x1e, 0xb3, 0x05, 0x68, 0xc3, 0x71, 0x02,
	0xbf, 0xed, 0x0f, 0x22, 0x42, 0xe9, 0x66, 0xe0, 0x1f, 0xb8, 0x03, 0x64, 0xc0, 0x3c, 0xf1, 0xf1,
	0xbe, 0x47, 0x1c, 0xa3, 0x74, 0xa7, 0x74, 0xaf, 0x6a, 0x25, 0x4d, 0xb4, 0x02, 0x73, 0x87, 0x01,
	0x65, 0xd4, 0x28, 0xdf, 0x99, 0xb9, 0x57, 0xb3, 0x64, 0xc3, 0xb4, 0x00, 0x36, 0x22, 0xfb, 0x50,
	0x49, 0xaf, 0xc0, 0x1c, 0x1e, 0x3a, 0x4f, 0x1e, 0x0b, 0xd9, 0xba, 0x25, 0x1b, 0x7c, 0xcc, 0x30,
	0xb4, 0x9f, 0x3c, 0xf6, 0x88, 0x51, 0x16, 0xf4, 0xa4, 0xc9, 0xf9, 0xe9, 0xa3, 0x4f, 0x1f, 0x9c,
	0x18, 0x33, 0x92, 0x5f, 0x34, 0xcc, 0x9f, 0x41, 0x6d, 0x73, 0xb7, 0x7d, 0xd6, 0x82, 0xcc, 0xdf,
	0xc0, 0xda, 0x66, 0xf7, 0x65, 0x1f, 0x47, 0x03, 0xc2, 0x5e, 0x32, 0xd7, 0x73, 0xbf, 0x17, 0x2a,
	0x50, 0x72, 0x4f, 0xc1, 0x60, 0xa2, 0x6b, 0xe3, 0x98, 0x44, 0x78, 0x40, 0x72, 0x1c, 0x62, 0xa0,
	0x39, 0x6b, 0x62, 0xbf, 0xf9, 0x77, 0x25, 0x58, 0xda, 0x24, 0x11, 0xdb, 0xc1, 0x3e, 0x1e, 0x90,
	0xe8, 0x4c, 0xd5, 0x34, 0x60, 0xe6, 0x30, 0xde, 0x17, 0x1f, 0x57, 0xb3, 0xf8, 0x4f, 0xf4, 0x1c,
	0x6a, 0x11, 0xa1, 0x41, 0x1c, 0xd9, 0x84, 0x8a, 0x8f, 0x5b, 0x78, 0x78, 0xaf, 0x29, 0x37, 0xa5,
	0x89, 0x43, 0xb7, 0xc9, 0x37, 0xa5, 0x79, 0xfc, 0x61, 0xd3, 0x52, 0x4c, 0x16, 0x79, 0x1d, 0xbb,
	0x11, 0x19, 0x12, 0x9f, 0x51, 0x2b, 0x13, 0xe5, 0x23, 0x33, 0x3c, 0x30, 0x66, 0xe5, 0xc8, 0x0c,
	0x0f, 0xcc, 0xbf, 0x2f, 0x41, 0x7d, 0x33, 0x88, 0x48, 0x6b, 0xb7, 0xa7, 0xd6, 0x65, 0xc2, 0xa2,
	0x2d, 0x09, 0xed, 0x21, 0x1e, 0x10, 0xb1, 0xb8, 0x9a, 0xa5, 0xd1, 0x50, 0x13, 0x90, 0x6a, 0x77,
	0xbd, 0x78, 0xe0, 0xfa, 0x92, 0x53, 0x2e, 0xb8, 0xa0, 0x27, 0xff, 0xad, 0x33, 0xfa, 0xb7, 0x9a,
	0xb0, 0x18, 0x91, 0xd0, 0x73, 0x6d, 0xbc, 0x19, 0xc4, 0x3e, 0x13, 0x4b, 0xab, 0x5b, 0x1a, 0xcd,
	0xfc, 0x1c, 0xee, 0xb4, 0xc8, 0x01, 0x8e, 0x3d, 0xd6, 0x0d, 0x9c, 0x96, 0x4b, 0xa3, 0x38, 0xe4,
	0x7a, 0x7d, 0x16, 0x3b, 0x03, 0xc2, 0xce, 0xdc, 0xd7, 0x97, 0xb0, 0xaa, 0xa4, 0x13, 0xed, 0x24,
	0x87, 0xf3, 0x33, 0xa8, 0x46, 0xe4, 0x75, 0x4c, 0xf8, 0x29, 0x2c, 0x09, 0xa5, 0xde, 0x6e, 0x4a,
	0x8b, 0x48, 0x15, 0x49, 0x2d, 0xc5, 0x20, 0x45, 0xac, 0x54, 0xc0, 0xfc, 0xcf, 0x0a, 0x2c, 0x6f,
	0x89, 0xa3, 0xbe, 0x8d, 0x19, 0x79, 0x83, 0x4f, 0xd5, 0xa0, 0x3f, 0x87, 0x06, 0x8e, 0x59, 0x40,
	0x6d, 0xec, 0x91, 0x2d, 0x6d, 0x45, 0x63, 0x74, 0xfe, 0xf1, 0x29, 0x6d, 0x07, 0x9f, 0xa8, 0xe3,
	0xac, 0xd1, 0x74, 0x1e, 0xd7, 0x57, 0x47, 0x5b, 0xa3, 0xa1, 0xbb, 0x70, 0xc5, 0x0e, 0x7c, 0x9f,
	0xd8, 0xac, 0xef, 0x0e, 0x49, 0x10, 0x33, 0xb5, 0xc3, 0x23, 0x54, 0xf4, 0x18, 0x66, 0xec, 0x30,
	0x36, 0xe6, 0xc4, 0xb7, 0x9a, 0xc9, 0xb7, 0x4e, 0x3e, 0xf5, 0x16, 0x67, 0x47, 0x5f, 0x40, 0xdd,
	0x89, 0xb0, 0xeb, 0xb7, 0x94, 0x53, 0x30, 0x2a, 0x42, 0xfe, 0x46, 0x53, 0x7a, 0x8d, 0x66, 0xe2,
	0x35, 0x9a, 0x09, 0x83, 0xa5, 0xf3, 0xe7, 0xf7, 0x66, 0x5e, 0xdf, 0xfd, 0x27, 0x30, 0x43, 0xfc,
	0x63, 0xa3, 0x7a, 0x67, 0xe6, 0xde, 0xc2, 0xc3, 0x77, 0x92, 0x05, 0x15, 0xa8, 0xb5, 0xb9, 0xe5,
	0x1f, 0x6f, 0xf9, 0x2c, 0x3a, 0xb5, 0xb8, 0x00, 0x7a, 0x04, 0x15, 0x0f, 0xef, 0x13, 0x8f, 0x1a,
	0x35, 0xb1, 0x96, 0x9b, 0x89, 0xa8, 0x12, 0xea, 0x88, 0x4e, 0xf5, 0x11, 0x8a, 0x15, 0xfd, 0x39,
	0x2c, 0xfa, 0x81, 0x43, 0x7a, 0xc4, 0x23, 0x36, 0x0b, 0x22, 0x03, 0xc4, 0xac, 0x1f, 0x4c, 0x9b,
	0x75, 0x37, 0xc7, 0x2f, 0xa7, 0xd7, 0x86, 0x40, 0xef, 0xc1, 0x5c, 0x18, 0x44, 0x8c, 0x1a, 0x0b,
	0x62, 0xac, 0xe5, 0x64, 0xac, 0x2e, 0x27, 0xaa, 0xe9, 0x25, 0x87, 0x6e, 0xc2, 0x8b, 0x97, 0x37,
	0xe1, 0xa7, 0x50, 0xa7, 0xc4, 0x8e, 0x08, 0xfb, 0x2a, 0xf0, 0xe2, 0x21, 0xa1, 0x46, 0x5d, 0x4c,
	0xbd, 0x92, 0x4c, 0xdd, 0xcb, 0x75, 0x5a, 0x3a, 0x2b, 0x7a, 0x0f, 0x66, 0xbf, 0x3f, 0x0e, 0x7d,
	0xe3, 0x8a, 0x98, 0xfe, 0x5a, 0x22, 0xf2, 0x2d, 0x89, 0x82, 0xaf, 0xba, 0xbb, 0x6a, 0xbd, 0x82,
	0x65, 0xed, 0x09, 0x54, 0x13, 0x95, 0x73, 0xaf, 0x71, 0x44, 0x4e, 0x95, 0x23, 0xe0, 0x3f, 0xb9,
	0xa3, 0x15, 0xb2, 0xca, 0xe4, 0x65, 0xe3, 0x69, 0xf9, 0x93, 0xd2, 0xda, 0x17, 0xb0, 0x34, 0xa6,
	0xb4, 0x8b, 0x0c, 0x60, 0x7e, 0x05, 0x68, 0xcb, 0x3f, 0x0e, 0x4e, 0x77, 0x08, 0x8b, 0x5c, 0xfb,
	0xec, 0x38, 0x82, 0x60, 0x96, 0x87, 0x0e, 0x35, 0x90, 0xf8, 0xcd, 0x69, 0x5c, 0xe9, 0xc2, 0x56,
	0xe6, 0x2c, 0xf1, 0xdb, 0xfc, 0xdb, 0x32, 0x2c, 0x6e, 0x63, 0xcf, 0x23, 0xa7, 0xe7, 0x09, 0x4d,
	0x6e, 0xce, 0xa1, 0xc9, 0x06, 0x7a, 0x08, 0xb3, 0x43, 0x42, 0x0f, 0x8d, 0x19, 0xa1, 0xef, 0xf5,
	0xec, 0xc4, 0x65, 0x63, 0x36, 0x77, 0x08, 0x3d, 0x94, 0xe7, 0x44, 0xf0, 0x9e, 0xc7, 0xbb, 0xe9,
	0x07, 0x63, 0xee, 0xd2, 0x07, 0x63, 0xed, 0x63, 0xa8, 0xa5, 0xd3, 0x5f, 0x48, 0xe3, 0x7f, 0x06,
	0xcb, 0x05, 0x66, 0xc3, 0x87, 0xc0, 0x61, 0x98, 0x0c, 0x81, 0xc3, 0x50, 0xe8, 0x85, 0x32, 0x37,
	0x48, 0xf5, 0xc2, 0x1b, 0xe6, 0xdf, 0x94, 0xe1, 0x8a, 0x92, 0x4f, 0x44, 0x3b, 0xb0, 0x2c, 0xfa,
	0x5e, 0x11, 0x61, 0x53, 0x03, 0xd9, 0xab, 0x7c, 0xec, 0xcd, 0x29, 0x06, 0x67, 0x21, 0x21, 0xb7,
	0x95, 0x17, 0xcb, 0x6f, 0x54, 0x59, 0xdf, 0xa8, 0x4d, 0x68, 0xc8, 0x79, 0x5c, 0x6f, 0x3f, 0x99,
	0x44, 0x46, 0x47, 0x23, 0x99, 0xa4, 0xdd, 0x79, 0xa6, 0xcf, 0x70, 0x55, 0x48, 0xb4, 0x53, 0x01,
	0xb4, 0x07, 0x2b, 0x6a, 0x10, 0x5f, 0x5b, 0xed, 0xac, 0x18, 0xe8, 0x56, 0x3a, 0x90, 0x5f, 0xb0,
	0x5c, 0xf9, 0x99, 0x6d, 0x4d, 0xd0, 0xfc, 0xc3, 0x55, 0x58, 0xdc, 0xf6, 0x82, 0x7d, 0xec, 0x29,
	0x75, 0xdc, 0x85, 0x59, 0x1c, 0xd9, 0x87, 0xc6, 0xba, 0x18, 0x11, 0x25, 0x23, 0x66, 0x40, 0xc7,
	0x12, 0xfd, 0xe8, 0x1e, 0x5c, 0xb5, 0x45, 0x7b, 0x17, 0x0f, 0x09, 0x0d, 0xb1, 0x9d, 0x04, 0xdf,
	0x51, 0x32, 0x0f, 0x32, 0x92, 0xf4, 0x15, 0xf6, 0x5c, 0x47, 0x7a, 0x65, 0xa9, 0x9b, 0x31, 0x3a,
	0xfa, 0x15, 0xdc, 0xb4, 0x03, 0x9f, 0x45, 0x81, 0xd7, 0xf5, 0xb0, 0x4f, 0x7a, 0xc4, 0x8e, 0x23,
	0x97, 0x9d, 0x6e, 0x69, 0xf1, 0x78, 0x1a, 0x0b, 0x7a, 0x05, 0xcb, 0x8e, 0x8c, 0xa0, 0x79, 0xd3,
	0x36, 0x6e, 0xeb, 0xfe, 0x33, 0xff, 0xc9, 0xcd, 0xd6, 0x38, 0xbf, 0xb4, 0x8b, 0xa2, 0x91, 0xd0,
	0x21, 0xac, 0x39, 0x13, 0x03, 0xbc, 0xda, 0x88, 0x7b, 0xc9, 0x3c, 0x67, 0x41, 0x01, 0x6b, 0xca,
	0x58, 0xe8, 0x01, 0x2c, 0x3b, 0x2e, 0xe5, 0x9f, 0xd5, 0x0d, 0x3c, 0xd7, 0x3e, 0xdd, 0x3c, 0x24,
	0xf6, 0x91, 0x34, 0xbb, 0xaa, 0x55, 0xd4, 0x85, 0x5e, 0x40, 0xc3, 0x19, 0x81, 0x0f, 0x2a, 0x00,
	0xae, 0x8f, 0xac, 0x68, 0x04, 0x5e, 0x58, 0x63, 0x72, 0x3c, 0x4e, 0xcb, 0xa3, 0xfb, 0x25, 0xf1,
	0x86, 0x7d, 0x42, 0x99, 0x8a, 0x87, 0x23, 0x54, 0xf4, 0x0e, 0xd4, 0x25, 0xa5, 0x1f, 0x61, 0xdb,
	0xf5, 0x07, 0x46, 0x55, 0xb0, 0xe9, 0xc4, 0x04, 0x26, 0xd6, 0x32, 0x98, 0x78, 0x17, 0xae, 0x88,
	0x03, 0x99, 0x9d, 0x1f, 0x90, 0x38, 0x40, 0xa7, 0xa2, 0x6f, 0x60, 0xc9, 0x0b, 0x6c, 0xec, 0xb9,
	0xec, 0xb4, 0xb3, 0xdf, 0x23, 0x8c, 0xf1, 0x39, 0xee, 0x88, 0xed, 0xfc, 0x45, 0xe1, 0x76, 0x76,
	0x46, 0xb9, 0xe5, 0x66, 0x8e, 0x8f, 0x82, 0xbe, 0x00, 0x38, 0xfa, 0x84, 0x2a, 0x8b, 0x30, 0x16,
	0x74, 0x54, 0xf5, 0xeb, 0x78, 0x9f, 0x44, 0x3e, 0x61, 0x84, 0x6a, 0x59, 0x82, 0x95, 0x13, 0x41,
	0x1f, 0xc1, 0xbc, 0x17, 0x0c, 0x06, 0x7c, 0x45, 0x8b, 0x23, 0xb1, 0x5d, 0xac, 0xa8, 0x23, 0x3b,
	0x95, 0x64, 0xc2, 0x8b, 0x36, 0xa0, 0xce, 0x3d, 0xee, 0xd6, 0x49, 0x88, 0x7d, 0xca, 0xcd, 0xa1,
	0xae, 0x0b, 0xef, 0xe4, 0x3b, 0x95, 0xb0, 0x2e, 0x81, 0x5e, 0xc0, 0x22, 0x27, 0xec, 0x12, 0xf6,
	0x26, 0x88, 0x8e, 0xa8, 0xf1, 0x13, 0xa1, 0x90, 0xbb, 0x85, 0x0a, 0xd9, 0xc9, 0x31, 0x2a, 0x60,
	0x90, 0x97, 0xe5, 0x3b, 0x31, 0x0c, 0x7c, 0x97, 0x05, 0x91, 0xeb, 0x0f, 0x38, 0x1a, 0x10, 0x31,
	0xb7, 0x6e, 0x8d, 0x50, 0xb9, 0x6b, 0x18, 0x32, 0x8f, 0x1a, 0x57, 0x75, 0xd7, 0xb0, 0xd3, 0xef,
	0xf4, 0x12, 0xd7, 0xc0, 0xfb, 0xd1, 0x2f, 0x61, 0x71, 0x18, 0x7b, 0xcc, 0xdd, 0xf4, 0x62, 0xca,
	0x48, 0x64, 0x34, 0x04, 0xff, 0x5a, 0xca, 0x9f, 0xeb, 0x53, 0x72, 0x1a, 0x3f, 0x0f, 0x44, 0x81,
	0x4f, 0xb2, 0x73, 0xb1, 0x24, 0x0e, 0x94, 0x46, 0x43, 0xdf, 0xc0, 0xb5, 0x20, 0x66, 0xfb, 0x41,
	0xec, 0x3b, 0xfd, 0x08, 0x1f, 0x1c, 0xb8, 0xb6, 0x34, 0x04, 0x03, 0x89, 0xc9, 0x7e, 0x9a, 0x4c,
	0xb6, 0x57, 0xc4, 0xa4, 0x66, 0x2d, 0x1e, 0x81, 0x9b, 0x5d, 0x98, 0x19, 0xd5, 0x73, 0xec, 0x7a,
	0x7b, 0x21, 0xf1, 0x8d, 0x65, 0x69, 0x76, 0x05, 0x5d, 0xdc, 0x17, 0x4a, 0x72, 0xb6, 0xe6, 0x15,
	0xe9, 0x0b, 0x47, 0xc8, 0xe8, 0x7d, 0x58, 0x0a, 0x23, 0x37, 0xe0, 0x0e, 0x6b, 0xd3, 0xc3, 0x94,
	0xf2, 0x1e, 0xe3, 0x9a, 0xe0, 0x1d, 0xef, 0x10, 0x88, 0x2d, 0x0a, 0x4e, 0x4e, 0x8d, 0x55, 0xf1,
	0x51, 0x19, 0x62, 0xe3, 0xc4, 0x14, 0xb1, 0xf1, 0x06, 0x7a, 0x02, 0x20, 0x7e, 0xbc, 0x72, 0x7d,
	0x97, 0x19, 0xd7, 0x05, 0xff, 0x75, 0x8d, 0xbf, 0xed, 0xbb, 0x89, 0xd3, 0xa9, 0x85, 0x09, 0x01,
	0xfd, 0x14, 0x66, 0xa8, 0x43, 0x0d, 0x43, 0x08, 0x2c, 0xa5, 0xb8, 0xac, 0x95, 0xec, 0x28, 0xef,
	0x4d, 0x32, 0xb1, 0x1b, 0x69, 0x26, 0xc6, 0x73, 0x2a, 0x46, 0x3c, 0x32, 0x24, 0x2c, 0xca, 0x7d,
	0xf4, 0x9a, 0xcc, 0xa9, 0xc6, 0x7b, 0xd0, 0xfb, 0x50, 0x61, 0x11, 0xb6, 0x49, 0x64, 0xdc, 0x14,
	0x33, 0xa5, 0x08, 0xb0, 0x2f, 0xa8, 0x09, 0xf8, 0x95, 0x3c, 0xe8, 0x0e, 0x2c, 0xb0, 0x28, 0xa6,
	0xac, 0x15, 0x0c, 0xb1, 0xeb, 0x1b, 0xb7, 0xc4, 0xb0, 0x79, 0x12, 0x5a, 0x85, 0x4a, 0x4c, 0xc9,
	0xce, 0x66, 0xd7, 0x78, 0x5b, 0x6c, 0x8b, 0x6a, 0xad, 0x3d, 0x07, 0x63, 0x92, 0x37, 0xbf, 0x10,
	0x32, 0x6c, 0xc1, 0x6a, 0xb1, 0x1b, 0xb9, 0x28, 0xbe, 0x1c, 0xb3, 0xbd, 0x0b, 0xa1, 0x9d, 0x5f,
	0xc0, 0x72, 0x81, 0x23, 0xe1, 0x02, 0x1e, 0x39, 0x26, 0x9e, 0x1a, 0x44, 0x36, 0xcc, 0x1f, 0x66,
	0xa0, 0x31, 0x8a, 0x20, 0xfe, 0x28, 0x19, 0x5e, 0x0e, 0x03, 0xcd, 0xea, 0x18, 0xe8, 0x72, 0x39,
	0x5d, 0x96, 0x40, 0x55, 0xce, 0x9f, 0x40, 0xdd, 0x85, 0x2b, 0x5e, 0x80, 0x9d, 0x67, 0xd8, 0xc3,
	0xbe, 0x4d, 0xa2, 0x76, 0x57, 0x84, 0xaf, 0x9a, 0x35, 0x42, 0xcd, 0xb2, 0xa2, 0xea, 0xc5, 0xb2,
	0xa2, 0xda, 0x8f, 0x98, 0x15, 0xc1, 0xb9, 0xb3, 0x22, 0xf3, 0x5f, 0xaa, 0xb0, 0x52, 0x84, 0xee,
	0xfe, 0x04, 0x53, 0xf9, 0x77, 0xa0, 0x6e, 0xc7, 0x94, 0x05, 0xc3, 0x1e, 0x89, 0x8e, 0x5d, 0x9b,
	0x88, 0xdd, 0xaf, 0x5a, 0x3a, 0x91, 0xdb, 0x82, 0x43, 0xf6, 0xe3, 0x81, 0xda, 0x5e, 0xd9, 0xe0,
	0xfe, 0xc1, 0x91, 0xce, 0xa3, 0x2a, 0xc8, 0xaa, 0x35, 0x5e, 0x1e, 0xa8, 0x5d, 0xbe, 0x3c, 0x00,
	0xfa, 0xd9, 0xfe, 0x58, 0x96, 0x07, 0x64, 0x72, 0xfd, 0xb3, 0x69, 0x48, 0x7c, 0xa4, 0x3e, 0x70,
	0x07, 0x16, 0xc8, 0x09, 0x23, 0x91, 0x8f, 0xbd, 0x76, 0x97, 0xa7, 0xdb, 0x33, 0xdc, 0xdb, 0xe5,
	0x48, 0x68, 0x5d, 0xc3, 0x29, 0x75, 0x31, 0x6f, 0x1e, 0x86, 0xdc, 0x83, 0xab, 0x59, 0xeb, 0x4b,
	0xc6, 0x42, 0x2a, 0x22, 0x78, 0xd5, 0x1a, 0x25, 0xe7, 0x4c, 0xe9, 0xea, 0xff, 0xc7, 0x94, 0x1a,
	0x85, 0xa6, 0xf4, 0x14, 0x8c, 0x3c, 0xa5, 0x27, 0x8d, 0x00, 0xfb, 0x03, 0x42, 0x8d, 0x25, 0xf1,
	0x55, 0x13, 0xfb, 0xd1, 0x26, 0x20, 0x0d, 0xe0, 0x08, 0xf3, 0x33, 0xd0, 0x64, 0x9b, 0x2c, 0x60,
	0xcf, 0x6c, 0x79, 0xf9, 0x4c, 0x5b, 0x1e, 0x4d, 0x76, 0x57, 0x0a, 0x92, 0xdd, 0x0f, 0x65, 0x6c,
	0xbc, 0xa6, 0xe3, 0x42, 0x7d, 0x47, 0x7b, 0x0e, 0xcd, 0x47, 0xca, 0x31, 0xd3, 0x5e, 0x3d, 0x7f,
	0xc1, 0xe3, 0xb1, 0x2a, 0x78, 0xc8, 0xe0, 0x7d, 0xa7, 0x78, 0xbe, 0x6f, 0x8f, 0x43, 0xff, 0xc7,
	0xa8, 0x7d, 0x98, 0x6d, 0xb8, 0x3e, 0xe1, 0x4b, 0x2e, 0x5a, 0x6c, 0x30, 0x3b, 0x60, 0x4c, 0x5a,
	0xe4, 0x94, 0xb1, 0x56, 0xa1, 0x42, 0xe3, 0x83, 0x03, 0xf7, 0x44, 0x0d, 0xa6, 0x5a, 0xe6, 0x67,
	0x70, 0x3b, 0x83, 0xde, 0x5b, 0xfe, 0xf1, 0x8e, 0x7b, 0x42, 0xa2, 0x0d, 0x07, 0x87, 0xec, 0xec,
	0x6a, 0xb4, 0xf9, 0x06, 0xae, 0x4f, 0xc0, 0xed, 0x53, 0x56, 0xc2, 0x0d, 0x50, 0xe6, 0x34, 0xc2,
	0x74, 0x64, 0x6e, 0x9a, 0x27, 0x71, 0x0e, 0x95, 0x30, 0x0b, 0xc0, 0x36, 0x23, 0x01, 0x49, 0x8e,
	0x64, 0xbe, 0x06, 0xd4, 0x09, 0xb0, 0xd3, 0x3b, 0x24, 0x8e, 0x93, 0x05, 0xea, 0x9f, 0x43, 0xc3,
	0xc3, 0x8c, 0xf8, 0xf6, 0x69, 0xff, 0x30, 0x22, 0xf4, 0x30, 0xf0, 0x1c, 0xb5, 0x3b, 0x63, 0x74,
	0xf3, 0x3e, 0xcc, 0x0e, 0x03, 0x87, 0xa0, 0x45, 0xa8, 0xb6, 0xda, 0xbd, 0x8d, 0x67, 0x9d, 0xad,
	0x56, 0xe3, 0x2d, 0xde, 0xea, 0xec, 0x6d, 0xbf, 0xda, 0xdb, 0xed, 0x7c, 0xd3, 0x28, 0xa1, 0x05,
	0x98, 0xdf, 0xda, 0x7d, 0xbe, 0x67, 0x6d, 0x6e, 0x35, 0xca, 0xe6, 0x5d, 0x80, 0x0c, 0x7a, 0x4f,
	0xd1, 0xc9, 0x36, 0x2c, 0x17, 0x24, 0x14, 0xd3, 0x77, 0x26, 0xa6, 0xa4, 0xdd, 0x79, 0xa6, 0x54,
	0xa1, 0x5a, 0xe6, 0x6f, 0xcb, 0xb0, 0x9c, 0xdf, 0x8d, 0x44, 0xb3, 0x3b, 0x50, 0x3f, 0x4a, 0x95,
	0xce, 0x7d, 0xa0, 0xac, 0x9d, 0xbc, 0x3b, 0x9e, 0x49, 0x15, 0x6e, 0xa7, 0xa5, 0x4b, 0xa3, 0x96,
	0x80, 0xb2, 0x43, 0xc2, 0x0e, 0x49, 0x2c, 0x77, 0x23, 0x57, 0x6e, 0xed, 0xa6, 0x3d, 0x05, 0x03,
	0xe5, 0xe4, 0xd0, 0x47, 0x30, 0x47, 0x99, 0xe3, 0x06, 0xaa, 0xc6, 0x92, 0x9a, 0x6f, 0x8f, 0x13,
	0x0b, 0x64, 0x25, 0x37, 0xf7, 0x75, 0x31, 0x25, 0x49, 0x97, 0xd5, 0xa2, 0x0a, 0xc2, 0x8c, 0x50,
	0xcd, 0x7f, 0x2b, 0xc3, 0x82, 0x18, 0x45, 0xe9, 0xe0, 0x63, 0xa8, 0x62, 0xa5, 0x95, 0xd1, 0xd2,
	0x51, 0x81, 0xca, 0xac, 0x94, 0x79, 0x4a, 0xc1, 0xa8, 0x29, 0x03, 0x8a, 0x2c, 0xe1, 0xdd, 0xd2,
	0x46, 0x2b, 0x8c, 0x23, 0xa9, 0x71, 0xce, 0xe6, 0x2b, 0x81, 0x1f, 0x42, 0x45, 0x26, 0x21, 0x2a,
	0xfc, 0xde, 0xd0, 0x06, 0xd2, 0xf2, 0x21, 0xc5, 0x88, 0x9e, 0x42, 0x2d, 0x85, 0xf0, 0x0a, 0x72,
	0xe9, 0xd3, 0xf7, 0x93, 0xde, 0x24, 0x9f, 0x48, 0xd9, 0x2f, 0xed, 0x8e, 0x7e, 0x57, 0x86, 0xa5,
	0xb1, 0x15, 0xfd, 0x51, 0x40, 0x8d, 0x02, 0x2b, 0xb3, 0x17, 0x03, 0x2b, 0xb9, 0x6d, 0x9c, 0x9b,
	0xe0, 0x33, 0x2b, 0xf9, 0x6d, 0x19, 0x8d, 0x3f, 0xf3, 0x05, 0x57, 0x49, 0xff, 0x3b, 0x0b, 0x2b,
	0x45, 0xfa, 0xbe, 0xfc, 0x61, 0x2b, 0xd2, 0x67, 0xf9, 0x9c, 0xfa, 0x9c, 0x39, 0x87, 0x3e, 0x67,
	0x27, 0xeb, 0x73, 0xee, 0xd2, 0xfa, 0xac, 0x14, 0xe2, 0xac, 0x79, 0x1d, 0x67, 0x15, 0xe9, 0x69,
	0x92, 0x7d, 0x54, 0xf3, 0x1b, 0xf1, 0x4b, 0x58, 0xe4, 0xa0, 0x84, 0x2a, 0xc7, 0xad, 0x00, 0x61,
	0x5a, 0xac, 0x18, 0x77, 0xea, 0x96, 0xc6, 0x3f, 0xb6, 0x91, 0x70, 0x56, 0xd5, 0x7c, 0xe1, 0xf2,
	0x89, 0xc3, 0x13, 0x58, 0xa5, 0x84, 0x72, 0x1f, 0xbe, 0x71, 0x70, 0xc0, 0x13, 0xfd, 0xb4, 0x30,
	0xba, 0x28, 0x74, 0x34, 0xa1, 0xf7, 0xd2, 0x46, 0xd9, 0x04, 0x34, 0x5e, 0xac, 0x99, 0x12, 0x69,
	0x36, 0xe0, 0x2a, 0x4f, 0xbb, 0x37, 0x06, 0xc4, 0x67, 0x97, 0xc4, 0x12, 0xdb, 0x70, 0x73, 0x4a,
	0xc9, 0xc6, 0xbc, 0xa7, 0x82, 0x64, 0x1d, 0x6a, 0x1b, 0x9d, 0xce, 0xde, 0xd7, 0xaf, 0x36, 0x76,
	0xbf, 0x69, 0xbc, 0x85, 0x96, 0xa0, 0x6e, 0x6d, 0x6d, 0xb7, 0x7b, 0x7d, 0xeb, 0x1b, 0x15, 0x2a,
	0xcd, 0xbf, 0xaa, 0xc2, 0x42, 0xd7, 0xf5, 0x82, 0xb3, 0x17, 0x72, 0x69, 0xa3, 0x98, 0xe0, 0x40,
	0x46, 0x0d, 0x67, 0xb6, 0xd8, 0x70, 0xb4, 0x53, 0x33, 0x57, 0x70, 0x6a, 0x8a, 0x1d, 0x87, 0x01,
	0xf3, 0xd4, 0x75, 0x88, 0x8d, 0xa3, 0xe4, 0x7e, 0x52, 0x35, 0x79, 0xbe, 0x24, 0xea, 0x27, 0x3d,
	0x3c, 0x0c, 0xbd, 0xa4, 0x10, 0x5b, 0xb2, 0x74, 0xe2, 0x8f, 0x96, 0xc4, 0x16, 0xd4, 0xff, 0xa1,
	0xb8, 0xfe, 0xaf, 0x1c, 0xc0, 0xc2, 0xc5, 0x1c, 0x80, 0x0d, 0xb7, 0x8f, 0x08, 0x09, 0xb1, 0xe7,
	0x1e, 0x73, 0x8d, 0xf1, 0x74, 0x4f, 0x9c, 0x40, 0x9e, 0x57, 0xf2, 0x23, 0x3e, 0x20, 0xaa, 0xe4,
	0x3a, 0x25, 0x77, 0x3b, 0x6b, 0x04, 0xf4, 0x12, 0x1a, 0x0e, 0x09, 0xbd, 0xe0, 0x94, 0x7f, 0x9e,
	0xcc, 0x7d, 0xd4, 0x15, 0xe5, 0x7b, 0x29, 0xe0, 0xc8, 0xce, 0x50, 0xb3, 0x35, 0xc2, 0x2b, 0x9d,
	0xcb, 0xd8, 0x10, 0xe8, 0x16, 0xd4, 0xa4, 0x12, 0x76, 0x70, 0xa8, 0x32, 0xb1, 0x8c, 0x80, 0x1e,
	0xc3, 0xbc, 0xba, 0xbd, 0x51, 0x49, 0xd8, 0x9a, 0x36, 0x97, 0x5e, 0x6d, 0x4e, 0x58, 0x73, 0x15,
	0xaf, 0x46, 0xbe, 0xe2, 0x95, 0xa0, 0x84, 0x25, 0x1d, 0x25, 0xe4, 0x57, 0xad, 0x7b, 0xc1, 0x0c,
	0x0f, 0x20, 0x1d, 0x0f, 0x08, 0x91, 0xb3, 0xf1, 0xc0, 0xb2, 0x8e, 0x07, 0x84, 0xd4, 0x14, 0x3c,
	0xb0, 0x09, 0xd7, 0x0a, 0xb5, 0x76, 0xa1, 0x3a, 0xda, 0x65, 0xfd, 0xd7, 0x1f, 0x4a, 0x80, 0xc6,
	0x75, 0x2a, 0x6e, 0x1e, 0x24, 0x21, 0xa9, 0x2c, 0x94, 0xd4, 0xcd, 0x83, 0x46, 0xe5, 0x46, 0xaa,
	0x28, 0xa2, 0x24, 0xab, 0x60, 0xbf, 0x46, 0x33, 0x3f, 0x85, 0x6b, 0x6e, 0x3a, 0x38, 0x8b, 0x02,
	0xcf, 0x23, 0xd1, 0x0e, 0xf7, 0x50, 0x0b, 0x30, 0xdf, 0xda, 0x7a, 0xbe, 0xf1, 0xb2, 0xd3, 0x6f,
	0xbc, 0x85, 0x00, 0x2a, 0xbd, 0xbe, 0xd5, 0xde, 0xec, 0x37, 0x4a, 0x68, 0x1e, 0x66, 0xf6, 0x9e,
	0x3f, 0x6f, 0x94, 0xcd, 0x0f, 0x60, 0x69, 0x4c, 0xe7, 0x53, 0x9c, 0xeb, 0x03, 0x58, 0x29, 0x52,
	0xf6, 0x14, 0x89, 0xd7, 0xb0, 0x90, 0xcb, 0x7c, 0x11, 0x82, 0x59, 0x9f, 0x67, 0x2f, 0xf2, 0x63,
	0xc5, 0xef, 0xf4, 0xf2, 0xb9, 0x9c, 0x5d, 0x3e, 0xa3, 0x35, 0xa8, 0xfa, 0x81, 0x43, 0xba, 0xd9,
	0xa5, 0x74, 0xda, 0x46, 0xeb, 0x00, 0xf2, 0xe5, 0x90, 0xe8, 0x9d, 0x15, 0xbd, 0x39, 0x8a, 0xa8,
	0x41, 0x66, 0x10, 0x3d, 0x7b, 0x8e, 0x64, 0x47, 0x04, 0x33, 0x92, 0xf5, 0x24, 0xde, 0x45, 0x2d,
	0x79, 0x62, 0xff, 0x14, 0x78, 0x3c, 0xea, 0x42, 0x67, 0x0a, 0x5c, 0xa8, 0xba, 0x75, 0x9a, 0xcd,
	0x6e, 0x9d, 0x54, 0x29, 0x7b, 0x2e, 0x2b, 0x65, 0xdf, 0xe2, 0x0e, 0x91, 0x11, 0x3f, 0x7d, 0x2d,
	0x52, 0xb3, 0x32, 0x02, 0xda, 0x80, 0x2b, 0xd4, 0x8e, 0x70, 0x48, 0xda, 0x3e, 0x23, 0xd1, 0x31,
	0xf6, 0x84, 0xd7, 0x9d, 0xea, 0x75, 0x46, 0x04, 0x78, 0xf2, 0x68, 0x07, 0x3e, 0x23, 0x27, 0xac,
	0x8b, 0xd9, 0xa1, 0x42, 0x1f, 0x79, 0x52, 0xde, 0x23, 0x8c, 0xc0, 0x8f, 0xf1, 0x57, 0x6a, 0x99,
	0x47, 0xf8, 0x14, 0xe6, 0xa9, 0x3a, 0xbf, 0xa0, 0xe7, 0x38, 0x99, 0x1e, 0xd5, 0x51, 0x4e, 0x44,
	0x15, 0x3f, 0xfa, 0x1c, 0xaa, 0x54, 0xdd, 0x9b, 0x2a, 0xbf, 0x7c, 0xa7, 0x48, 0x56, 0x72, 0x24,
	0x28, 0x32, 0x91, 0x30, 0x7f, 0x5b, 0x82, 0x5b, 0xd3, 0xf2, 0xb0, 0x29, 0xb1, 0x76, 0x0f, 0xae,
	0x0d, 0xe5, 0x5b, 0x89, 0xad, 0x93, 0xd0, 0x8d, 0x4e, 0xd3, 0x3a, 0x5c, 0xf9, 0x2c, 0xad, 0x16,
	0xcb, 0x99, 0x8f, 0xc1, 0x98, 0xb4, 0xe2, 0x29, 0x96, 0xf1, 0x17, 0x70, 0x7d, 0x82, 0x8e, 0xd0,
	0x66, 0xee, 0xf4, 0x8f, 0xe4, 0xb1, 0x63, 0x22, 0xbb, 0x8a, 0x31, 0xd1, 0x50, 0x22, 0x68, 0xee,
	0xc1, 0xed, 0x33, 0x98, 0xa7, 0x3f, 0x12, 0x49, 0x6d, 0xb2, 0xae, 0x1e, 0x84, 0xfc, 0x43, 0x0d,
	0x16, 0x72, 0xb7, 0x3e, 0x3c, 0xd6, 0x63, 0xdb, 0x26, 0x94, 0x76, 0x82, 0xc1, 0x73, 0xd7, 0x4b,
	0x8c, 0x5a, 0x27, 0xf2, 0x18, 0x9d, 0x11, 0x82, 0x68, 0x88, 0x93, 0x97, 0x27, 0xa3, 0x64, 0x51,
	0x6b, 0x95, 0x20, 0x4f, 0xdd, 0xb9, 0x48, 0x03, 0xd1, 0x89, 0xe8, 0x7d, 0x58, 0xb2, 0x83, 0x61,
	0x18, 0xf8, 0xdc, 0x97, 0x07, 0x83, 0x8e, 0xb8, 0x83, 0x90, 0x26, 0x33, 0xde, 0xa1, 0xce, 0xbd,
	0x1d, 0x47, 0x11, 0xf1, 0xed, 0x53, 0x95, 0xe1, 0xe4, 0x49, 0xdc, 0xb8, 0x1c, 0x9f, 0x5a, 0xe4,
	0x20, 0x22, 0xf4, 0xd0, 0xc2, 0x4c, 0x42, 0xf3, 0xe9, 0xc6, 0xa5, 0x0b, 0x64, 0xb7, 0xd4, 0xe2,
	0x5d, 0x60, 0x3c, 0x0c, 0x85, 0x05, 0xa5, 0xb7, 0xd4, 0x09, 0x15, 0x75, 0x60, 0x99, 0xe4, 0x5e,
	0xea, 0xf4, 0x34, 0xc3, 0x49, 0xcd, 0x6d, 0xfc, 0x31, 0x8f, 0x55, 0x24, 0x86, 0x3e, 0x87, 0x05,
	0x41, 0xee, 0x31, 0xcc, 0xa8, 0xa3, 0x4c, 0x68, 0xda, 0x28, 0x79, 0x76, 0xf4, 0x00, 0x96, 0xc9,
	0x89, 0xed, 0xc5, 0x0e, 0x69, 0xfb, 0x02, 0xe9, 0xca, 0x62, 0xe7, 0xa2, 0x50, 0x64, 0x51, 0x17,
	0xdf, 0xc8, 0x84, 0xdc, 0x55, 0x05, 0xd5, 0xba, 0xdc, 0xc8, 0x11, 0x72, 0x06, 0x1a, 0xaf, 0xe4,
	0x41, 0xe3, 0x03, 0x58, 0x76, 0xfd, 0xf1, 0x19, 0xaf, 0xca, 0x19, 0x0b, 0xba, 0xf8, 0x8c, 0x09,
	0x39, 0x99, 0x51, 0x16, 0x7d, 0x47, 0xc9, 0xa8, 0x09, 0xe8, 0x28, 0xde, 0x27, 0xc7, 0x6e, 0xc4,
	0x84, 0xcb, 0x3b, 0xc0, 0xb6, 0xa8, 0xf7, 0x8a, 0xab, 0xc0, 0xf1, 0x1e, 0x1e, 0x5e, 0xbc, 0xe4,
	0xec, 0x20, 0xc1, 0x95, 0xb6, 0x79, 0x78, 0x09, 0x23, 0xf7, 0xd8, 0xf5, 0xc8, 0x80, 0x38, 0xea,
	0xc6, 0x35, 0x47, 0x41, 0xcf, 0xe0, 0x56, 0x44, 0xb0, 0xe3, 0xfa, 0x84, 0xd2, 0xb6, 0xef, 0x32,
	0x17, 0x7b, 0x2d, 0xe2, 0xe1, 0xd3, 0x1e, 0xb1, 0x03, 0xdf, 0xa1, 0xaa, 0x8a, 0x3b, 0x95, 0x87,
	0x27, 0x51, 0x69, 0x7f, 0x97, 0x44, 0x6e, 0xe0, 0x24, 0xd2, 0xd7, 0x84, 0xf4, 0x84, 0x5e, 0xf4,
	0x39, 0xdc, 0x48, 0x7b, 0x9e, 0x63, 0xd7, 0x8b, 0x23, 0x92, 0x15, 0xf5, 0x56, 0x85, 0xe8, 0x64,
	0x06, 0xfe, 0x65, 0x94, 0x61, 0x16, 0x53, 0xe1, 0x58, 0xae, 0x0b, 0xf6, 0x1c, 0x45, 0x87, 0xe5,
	0xc6, 0xa5, 0x61, 0xb9, 0xf9, 0x2e, 0x2c, 0xa5, 0xb6, 0xbd, 0xe5, 0xdb, 0x81, 0xc8, 0x51, 0xab,
	0x30, 0xfb, 0xa2, 0xb7, 0xb7, 0xdb, 0x78, 0x8b, 0xff, 0xea, 0x6f, 0xfd, 0xa6, 0xdf, 0x28, 0x99,
	0xef, 0x02, 0xf0, 0x8c, 0xa4, 0xed, 0x7f, 0x47, 0x6c, 0x26, 0x0b, 0x8b, 0xb9, 0x9a, 0x63, 0x5a,
	0x81, 0x2c, 0x99, 0x0f, 0x92, 0xab, 0x5b, 0x8e, 0x62, 0xbe, 0x6d, 0x77, 0x7f, 0xdd, 0xe6, 0x03,
	0xd5, 0xa1, 0xd6, 0x69, 0x6f, 0x7f, 0xd9, 0xef, 0xf5, 0xb7, 0xba, 0xb2, 0x30, 0xd9, 0xda, 0xe8,
	0x6f, 0xb4, 0xf6, 0xb6, 0x1b, 0x65, 0xf3, 0x5d, 0xb8, 0x3a, 0x72, 0xe3, 0x9c, 0x1d, 0xcb, 0x52,
	0x3e, 0xd9, 0xdb, 0x84, 0xeb, 0x13, 0xde, 0xae, 0xf2, 0x38, 0xcd, 0x93, 0x06, 0x05, 0xf3, 0x78,
	0x42, 0xb0, 0x0a, 0x95, 0x21, 0x19, 0x06, 0xd1, 0x69, 0x52, 0x2f, 0x96, 0x2d, 0xf3, 0x77, 0x25,
	0xa8, 0xa5, 0xf7, 0xd5, 0x53, 0xdc, 0xaa, 0x01, 0xf3, 0xb1, 0x43, 0x45, 0x08, 0x96, 0x03, 0x24,
	0x4d, 0x8e, 0x24, 0x62, 0x4a, 0x76, 0xb9, 0x27, 0xf4, 0x5e, 0xbc, 0x61, 0xea, 0x95, 0x91, 0x46,
	0xe3, 0xae, 0x2f, 0xa6, 0xa4, 0x1f, 0xc5, 0x94, 0xbd, 0x09, 0x22, 0x76, 0x78, 0xca, 0x19, 0x65,
	0x69, 0x70, 0xbc, 0xc3, 0xfc, 0x4b, 0x58, 0xcc, 0x57, 0xfa, 0x39, 0xc6, 0x18, 0x72, 0x40, 0x22,
	0x66, 0x97, 0xdf, 0x94, 0x11, 0x52, 0x60, 0x56, 0xce, 0x01, 0x33, 0x7e, 0x5e, 0xc4, 0x08, 0xb9,
	0x82, 0x73, 0x8e, 0x62, 0xfe, 0x47, 0x19, 0xae, 0x9c, 0x37, 0xdc, 0x8d, 0x41, 0xa5, 0xf2, 0xb4,
	0x6c, 0x73, 0x26, 0xef, 0x38, 0xc4, 0x32, 0xbc, 0x83, 0x9e, 0x3b, 0xf0, 0xd3, 0xdb, 0xdc, 0x1c,
	0x65, 0xf4, 0xa6, 0x7e, 0x6e, 0xfc, 0xa6, 0xfe, 0x57, 0x50, 0x75, 0x7c, 0xba, 0x49, 0xb8, 0xbf,
	0xa9, 0xe8, 0x4f, 0x67, 0xf5, 0xf5, 0x37, 0x5b, 0x8a, 0x4d, 0x26, 0x2b, 0xa9, 0x94, 0x78, 0x3f,
	0x26, 0xe0, 0xe1, 0x0e, 0xa1, 0x87, 0xea, 0x95, 0xc7, 0xbc, 0x7a, 0x3f, 0x36, 0x42, 0x5f, 0xfb,
	0x0c, 0xea, 0xda, 0x30, 0x17, 0x4a, 0x17, 0xb6, 0xa1, 0xae, 0x63, 0x01, 0x13, 0x16, 0x93, 0x6b,
	0xb8, 0x14, 0x0f, 0xd4, 0x2d, 0x8d, 0x56, 0xb4, 0x79, 0xe6, 0xff, 0x94, 0xe0, 0x5a, 0x4f, 0x66,
	0xe5, 0xd2, 0xbe, 0x82, 0xb3, 0x91, 0xd1, 0xe7, 0x70, 0x43, 0xfe, 0x4c, 0x13, 0x67, 0xfa, 0xec,
	0x54, 0xbd, 0x65, 0x50, 0xd0, 0x77, 0x32, 0xc3, 0x84, 0xdd, 0x3b, 0xcf, 0x8b, 0xce, 0x07, 0xb0,
	0x1c, 0x91, 0x37, 0x91, 0xcb, 0xc8, 0x46, 0x18, 0x7e, 0xd9, 0xef, 0x77, 0xbb, 0x51, 0xb0, 0x4f,
	0x92, 0x47, 0x66, 0x05, 0x5d, 0x23, 0x67, 0xa2, 0x32, 0x7a, 0x26, 0xcc, 0xaf, 0xe1, 0xfa, 0x84,
	0x22, 0xfb, 0xf4, 0x23, 0x1a, 0xc4, 0x2c, 0x8c, 0xd9, 0x06, 0x7d, 0x41, 0xd3, 0x07, 0x82, 0x1a,
	0xcd, 0xfc, 0xc7, 0x12, 0x2c, 0xe6, 0xdf, 0x8b, 0xa0, 0x8f, 0x60, 0xde, 0xc1, 0x0c, 0x3b, 0xc1,
	0x60, 0xb4, 0x0c, 0x2a, 0xd9, 0x5a, 0xb2, 0x33, 0x41, 0xbf, 0x8a, 0x17, 0x7d, 0x06, 0x35, 0xcf,
	0x1d, 0x1c, 0x32, 0xca, 0x48, 0xa8, 0x80, 0xe7, 0xdb, 0xba, 0x60, 0x87, 0x77, 0xf7, 0x18, 0x09,
	0x93, 0x84, 0x36, 0xe5, 0x47, 0x0f, 0xa1, 0xf2, 0xbd, 0x1b, 0x1e, 0xa9, 0xda, 0x4f, 0x2e, 0xea,
	0x4b, 0xc9, 0x6f, 0x45, 0x5f, 0x92, 0x40, 0x4b, 0x4e, 0xf3, 0x3e, 0x2c, 0x17, 0x2c, 0x88, 0x6b,
	0x03, 0x3b, 0x8e, 0x80, 0xfd, 0xf2, 0x7c, 0x26, 0x4d, 0xf3, 0xaf, 0x4b, 0x70, 0xad, 0x70, 0x25,
	0x93, 0x65, 0xb8, 0x29, 0x4a, 0xcf, 0xdf, 0x0f, 0x8e, 0x88, 0xaf, 0xce, 0x63, 0x9e, 0xc4, 0x37,
	0xce, 0xe6, 0x63, 0x4a, 0x37, 0xa4, 0x7c, 0x4a, 0x46, 0x11, 0x37, 0x72, 0xdc, 0x24, 0x89, 0x32,
	0x74, 0xd5, 0x32, 0x9b, 0x80, 0xc6, 0x3f, 0x6e, 0xca, 0xea, 0x7f, 0x5f, 0x86, 0xba, 0x7a, 0xf7,
	0x77, 0xe6, 0xbe, 0x3f, 0xc9, 0x52, 0x9f, 0xb2, 0x5e, 0x59, 0x50, 0x23, 0x4c, 0x48, 0x7e, 0x1e,
	0x41, 0xe5, 0x3b, 0x4c, 0x06, 0x24, 0x52, 0xdb, 0x70, 0x73, 0x44, 0xec, 0x85, 0xe8, 0x4c, 0xf6,
	0x41, 0xb2, 0x72, 0xe8, 0x11, 0x46, 0xc1, 0xb1, 0xeb, 0x90, 0x48, 0xe5, 0x84, 0x69, 0x1b, 0xdd,
	0xcf, 0xb2, 0xa9, 0x39, 0xfd, 0xc5, 0xf9, 0x84, 0x1c, 0xea, 0x51, 0x7a, 0x10, 0x2a, 0x85, 0x2b,
	0x28, 0x3c, 0x09, 0x0f, 0x60, 0xa5, 0xe8, 0xbb, 0xa6, 0xa4, 0x2a, 0x4c, 0x9e, 0x9d, 0x91, 0x4f,
	0x4a, 0x32, 0xdb, 0xd2, 0x58, 0x66, 0x5b, 0xce, 0x32, 0xdb, 0x4f, 0xd3, 0x88, 0x29, 0x75, 0xf4,
	0x93, 0x42, 0x1d, 0xed, 0x08, 0x96, 0x64, 0x9d, 0x2a, 0xa8, 0x3e, 0x85, 0x1b, 0x13, 0x99, 0xd0,
	0xdb, 0x00, 0x43, 0x7c, 0xf2, 0x4a, 0xa0, 0x02, 0xaa, 0x9c, 0x62, 0x6d, 0x88, 0x4f, 0xc4, 0x21,
	0xa1, 0xe6, 0x3f, 0x95, 0xd3, 0x25, 0x6b, 0x07, 0xe6, 0x3c, 0x4b, 0x16, 0xef, 0xe3, 0x82, 0x7d,
	0xd2, 0x63, 0x38, 0x62, 0x71, 0x28, 0x80, 0x9b, 0xca, 0xec, 0xc7, 0x3b, 0x78, 0x58, 0x7d, 0x1d,
	0x93, 0xe8, 0x34, 0x2d, 0x46, 0xd4, 0xad, 0x8c, 0xf0, 0x63, 0xbd, 0x55, 0xe7, 0xae, 0xe9, 0x3b,
	0x7c, 0x8c, 0xf7, 0x42, 0x46, 0xbf, 0x24, 0x38, 0x54, 0x09, 0x8f, 0x46, 0xe3, 0x27, 0x6b, 0x88,
	0x4f, 0x7a, 0x21, 0xf6, 0xa9, 0x4a, 0x74, 0xd2, 0x36, 0x7a, 0x04, 0xb3, 0x3c, 0x31, 0x54, 0xb9,
	0xcd, 0xed, 0xc2, 0x63, 0xc2, 0x93, 0xc3, 0xe4, 0x5a, 0x9f, 0x33, 0x9b, 0x1f, 0xc0, 0xf5, 0x09,
	0x0c, 0x3c, 0xe2, 0xd8, 0x61, 0x9c, 0x28, 0x5e, 0xfc, 0x36, 0xff, 0x79, 0x0e, 0x2a, 0x5f, 0x89,
	0x71, 0xd1, 0x67, 0xb0, 0xc0, 0x2d, 0x7a, 0x28, 0xff, 0xbf, 0xa5, 0x1c, 0x63, 0x5a, 0xe5, 0x1b,
	0xfb, 0x6b, 0x97, 0x95, 0xe7, 0x46, 0x4d, 0xa8, 0xc9, 0xf7, 0xe5, 0xb6, 0xef, 0x2a, 0x83, 0x4c,
	0x1f, 0x05, 0xa6, 0xff, 0x4b, 0xb3, 0xaa, 0x82, 0x67, 0xd3, 0x77, 0xd1, 0xa7, 0xb0, 0x28, 0x7e,
	0x73, 0x5d, 0x3a, 0x7e, 0xf2, 0x77, 0xaf, 0xd4, 0x74, 0xb4, 0x3f, 0x6b, 0x59, 0x1a, 0x2b, 0x7a,
	0x1f, 0x2a, 0x03, 0xf1, 0x77, 0x04, 0x75, 0xd5, 0xb6, 0x52, 0xf4, 0x27, 0x05, 0x4b, 0xf1, 0xa0,
	0x87, 0x50, 0x55, 0xd7, 0xed, 0xc9, 0x5e, 0xae, 0x8e, 0x3c, 0x5d, 0x49, 0x6f, 0xbb, 0x12, 0x3e,
	0x31, 0x83, 0x78, 0x3d, 0xa7, 0x2c, 0x74, 0xa5, 0xe8, 0x75, 0xac, 0xa5, 0x78, 0xd0, 0x7b, 0x30,
	0x37, 0xe4, 0x11, 0x4b, 0x15, 0x78, 0x96, 0x0b, 0x2e, 0x5c, 0x2d, 0xc9, 0x81, 0x3e, 0x82, 0x1a,
	0xdf, 0x24, 0x3c, 0x20, 0x3e, 0x53, 0xdb, 0x9a, 0xbe, 0xb5, 0x1c, 0xb9, 0x00, 0xb1, 0x32, 0x4e,
	0xf1, 0x3c, 0xc5, 0xf5, 0x02, 0xa6, 0x8a, 0x3c, 0xcb, 0x05, 0xc5, 0x5a, 0x4b, 0x72, 0xa0, 0x4f,
	0xb4, 0x3b, 0x70, 0xd0, 0xff, 0x26, 0x30, 0x5a, 0x60, 0xd3, 0xee, 0xbd, 0x1f, 0x8e, 0x95, 0x76,
	0x56, 0x8b, 0xf1, 0x56, 0x56, 0xd0, 0x41, 0x2f, 0x61, 0x95, 0xea, 0x70, 0xe5, 0x6b, 0xb2, 0x7f,
	0x18, 0x04, 0x47, 0xaa, 0xc4, 0x9e, 0x46, 0xc7, 0x42, 0x50, 0x63, 0x4d, 0x10, 0xe6, 0x2e, 0x95,
	0xa9, 0x37, 0xe1, 0x75, 0xfd, 0x5c, 0x68, 0xd1, 0xc1, 0x4a, 0xb8, 0xcc, 0x0d, 0xa8, 0x6b, 0x7f,
	0xef, 0xb9, 0xf8, 0xeb, 0x91, 0x67, 0x6b, 0xff, 0xfa, 0xc3, 0x7a, 0xe9, 0xdf, 0x7f, 0x58, 0x2f,
	0xfd, 0xd7, 0x0f, 0xeb, 0xa5, 0xdf, 0xff, 0xf7, 0xfa, 0x5b, 0xdf, 0x56, 0x8f, 0x3f, 0xc4, 0x5e,
	0x78, 0x88, 0x1f, 0xee, 0x57, 0x44, 0x39, 0xe1, 0xd1, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x00,
	0x6c, 0x79, 0x9a, 0x5e, 0x3a, 0x00, 0x00,
}

func (m *AddonIngressConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddonIngressConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArchConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArchConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Amd64 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Amd64))
	}
	if m.Ppc64Le != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Ppc64Le))
	}
	if m.S390X != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.S390X))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CNIConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNIConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CPUTargetUtilizationConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUTargetUtilizationConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TargetAverageUtilization != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.TargetAverageUtilization))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CertManagerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertManagerConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Hub) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Hub)))
		i += copy(dAtA[i:], m.Hub)
	}
	if m.Resources != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Resources.Size()))
		n1, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CoreDNSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoreDNSConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CoreDNSImage) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.CoreDNSImage)))
		i += copy(dAtA[i:], m.CoreDNSImage)
	}
	if len(m.CoreDNSPluginImage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.CoreDNSPluginImage)))
		i += copy(dAtA[i:], m.CoreDNSPluginImage)
	}
	if m.Enabled {
		dAtA[i] = 0x18
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DefaultPodDisruptionBudgetConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultPodDisruptionBudgetConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DefaultResourcesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultResourcesConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Requests != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Requests.Size()))
		n2, err := m.Requests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EgressGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AutoscaleEnabled {
		dAtA[i] = 0x8
		i++
		if m.AutoscaleEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoscaleMax != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMin))
	}
	if len(m.ConnectTimeout) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ConnectTimeout)))
		i += copy(dAtA[i:], m.ConnectTimeout)
	}
	if m.Cpu != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Cpu.Size()))
		n3, err := m.Cpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DrainDuration != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.DrainDuration.Size()))
		n4, err := m.DrainDuration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Enabled {
		dAtA[i] = 0x38
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0x42
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Labels != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Labels.Size()))
		n5, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0x52
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Resources != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Resources.Size()))
		n6, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.SecretVolumes) > 0 {
		for _, msg := range m.SecretVolumes {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Zvpn != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Zvpn.Size()))
		n7, err := m.Zvpn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyMetricsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyMetricsConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Host) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GalleyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GalleyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Mesh) > 0 {
		for k, _ := range m.Mesh {
			dAtA[i] = 0x1a
			i++
			v := m.Mesh[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if m.Resources != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Resources.Size()))
		n8, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GatewayLabelsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayLabelsConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.App) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.App)))
		i += copy(dAtA[i:], m.App)
	}
	if len(m.Istio) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Istio)))
		i += copy(dAtA[i:], m.Istio)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GatewaysConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewaysConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IstioEgressgateway != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.IstioEgressgateway.Size()))
		n9, err := m.IstioEgressgateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Enabled {
		dAtA[i] = 0x10
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IstioIlbgateway != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.IstioIlbgateway.Size()))
		n10, err := m.IstioIlbgateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.IstioIngressgateway != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.IstioIngressgateway.Size()))
		n11, err := m.IstioIngressgateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GlobalConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ConfigNamespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ConfigNamespace)))
		i += copy(dAtA[i:], m.ConfigNamespace)
	}
	if m.ConfigValidation {
		dAtA[i] = 0x10
		i++
		if m.ConfigValidation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ControlPlaneSecurityEnabled {
		dAtA[i] = 0x18
		i++
		if m.ControlPlaneSecurityEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DefaultPodDisruptionBudget != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.DefaultPodDisruptionBudget.Size()))
		n12, err := m.DefaultPodDisruptionBudget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.DisablePolicyChecks {
		dAtA[i] = 0x28
		i++
		if m.DisablePolicyChecks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DefaultResources != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.DefaultResources.Size()))
		n13, err := m.DefaultResources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.EnableHelmTest {
		dAtA[i] = 0x38
		i++
		if m.EnableHelmTest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableTracing {
		dAtA[i] = 0x40
		i++
		if m.EnableTracing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Hub) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Hub)))
		i += copy(dAtA[i:], m.Hub)
	}
	if len(m.IstioNamespace) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IstioNamespace)))
		i += copy(dAtA[i:], m.IstioNamespace)
	}
	if m.K8SIngress != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.K8SIngress.Size()))
		n14, err := m.K8SIngress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Logging != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Logging.Size()))
		n15, err := m.Logging.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.MeshExpansion != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.MeshExpansion.Size()))
		n16, err := m.MeshExpansion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.MonitoringPort != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.MonitoringPort))
	}
	if m.Mtls != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Mtls.Size()))
		n17, err := m.Mtls.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.MultiCluster != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.MultiCluster.Size()))
		n18, err := m.MultiCluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.OneNamespace {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.OneNamespace {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OutboundTrafficPolicy != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.OutboundTrafficPolicy.Size()))
		n19, err := m.OutboundTrafficPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.PolicyCheckFailOpen {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.PolicyCheckFailOpen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PolicyNamespace) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.PolicyNamespace)))
		i += copy(dAtA[i:], m.PolicyNamespace)
	}
	if len(m.PriorityClassName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.PriorityClassName)))
		i += copy(dAtA[i:], m.PriorityClassName)
	}
	if m.Proxy != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Proxy.Size()))
		n20, err := m.Proxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.ProxyInit != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ProxyInit.Size()))
		n21, err := m.ProxyInit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Sds != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Sds.Size()))
		n22, err := m.Sds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if len(m.TelemetryNamespace) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.TelemetryNamespace)))
		i += copy(dAtA[i:], m.TelemetryNamespace)
	}
	if m.Tracer != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Tracer.Size()))
		n23, err := m.Tracer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.TrustDomain) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.TrustDomain)))
		i += copy(dAtA[i:], m.TrustDomain)
	}
	if m.UseMCP {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		if m.UseMCP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Arch != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Arch.Size()))
		n24, err := m.Arch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.DefaultNodeSelector) > 0 {
		for k, _ := range m.DefaultNodeSelector {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			v := m.DefaultNodeSelector[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.LocalityLbSetting) > 0 {
		for k, _ := range m.LocalityLbSetting {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			v := m.LocalityLbSetting[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.MeshNetworks) > 0 {
		for k, _ := range m.MeshNetworks {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			v := m.MeshNetworks[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GlobalLoggingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalLoggingConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Level) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Level)))
		i += copy(dAtA[i:], m.Level)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ILBGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ILBGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AutoscaleEnabled {
		dAtA[i] = 0x8
		i++
		if m.AutoscaleEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoscaleMax != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMin))
	}
	if m.Enabled {
		dAtA[i] = 0x20
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Cpu != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Cpu.Size()))
		n25, err := m.Cpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Labels != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Labels.Size()))
		n26, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.LoadBalancerIP) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.LoadBalancerIP)))
		i += copy(dAtA[i:], m.LoadBalancerIP)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x42
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Resources != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Resources.Size()))
		n27, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.SecretVolumes) > 0 {
		for _, msg := range m.SecretVolumes {
			dAtA[i] = 0x52
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngressGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AutoscaleEnabled {
		dAtA[i] = 0x8
		i++
		if m.AutoscaleEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoscaleMax != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMin))
	}
	if len(m.ConnectTimeout) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ConnectTimeout)))
		i += copy(dAtA[i:], m.ConnectTimeout)
	}
	if m.Cpu != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Cpu.Size()))
		n28, err := m.Cpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.CustomService {
		dAtA[i] = 0x30
		i++
		if m.CustomService {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Debug) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Debug)))
		i += copy(dAtA[i:], m.Debug)
	}
	if len(m.Domain) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Domain)))
		i += copy(dAtA[i:], m.Domain)
	}
	if m.DrainDuration != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.DrainDuration.Size()))
		n29, err := m.DrainDuration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Enabled {
		dAtA[i] = 0x50
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0x5a
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ExternalIPs) > 0 {
		for _, s := range m.ExternalIPs {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.K8SIngress {
		dAtA[i] = 0x68
		i++
		if m.K8SIngress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.K8SIngressHttps {
		dAtA[i] = 0x70
		i++
		if m.K8SIngressHttps {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Labels != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Labels.Size()))
		n30, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.LoadBalancerIP) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.LoadBalancerIP)))
		i += copy(dAtA[i:], m.LoadBalancerIP)
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.MeshExpansionPorts) > 0 {
		for _, msg := range m.MeshExpansionPorts {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if m.Sds != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Sds.Size()))
		n31, err := m.Sds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.SecretVolumes) > 0 {
		for _, msg := range m.SecretVolumes {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Zvpn != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Zvpn.Size()))
		n32, err := m.Zvpn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngressGatewaySdsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGatewaySdsConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngressGatewayZvpnConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGatewayZvpnConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Suffix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Suffix)))
		i += copy(dAtA[i:], m.Suffix)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KubernetesEnvMixerAdapterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesEnvMixerAdapterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KubernetesIngressConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesIngressConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableHttps {
		dAtA[i] = 0x10
		i++
		if m.EnableHttps {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.GatewayName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.GatewayName)))
		i += copy(dAtA[i:], m.GatewayName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoadSheddingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadSheddingConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LatencyThreshold) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.LatencyThreshold)))
		i += copy(dAtA[i:], m.LatencyThreshold)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MTLSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MTLSConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MeshExpansionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeshExpansionConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseILB {
		dAtA[i] = 0x10
		i++
		if m.UseILB {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MixerAdaptersConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MixerAdaptersConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kubernetesenv != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Kubernetesenv.Size()))
		n33, err := m.Kubernetesenv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Prometheus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Prometheus.Size()))
		n34, err := m.Prometheus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Stdio != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Stdio.Size()))
		n35, err := m.Stdio.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.UseAdapterCRDs {
		dAtA[i] = 0x20
		i++
		if m.UseAdapterCRDs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MixerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MixerConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Adapters != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Adapters.Size()))
		n36, err := m.Adapters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Enabled {
		dAtA[i] = 0x10
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0x1a
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.Policy != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Policy.Size()))
		n37, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Telemetry != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Telemetry.Size()))
		n38, err := m.Telemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MixerPolicyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MixerPolicyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AutoscaleEnabled {
		dAtA[i] = 0x8
		i++
		if m.AutoscaleEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoscaleMax != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMin))
	}
	if m.Cpu != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Cpu.Size()))
		n39, err := m.Cpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Enabled {
		dAtA[i] = 0x28
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MixerTelemetryConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MixerTelemetryConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Adapters != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Adapters.Size()))
		n40, err := m.Adapters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.AutoscaleEnabled {
		dAtA[i] = 0x10
		i++
		if m.AutoscaleEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoscaleMax != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMin))
	}
	if m.Cpu != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Cpu.Size()))
		n41, err := m.Cpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Enabled {
		dAtA[i] = 0x30
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0x3a
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.Loadshedding != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Loadshedding.Size()))
		n42, err := m.Loadshedding.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if m.Resources != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Resources.Size()))
		n43, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.SessionAffinityEnabled {
		dAtA[i] = 0x60
		i++
		if m.SessionAffinityEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MultiClusterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeAgentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAgentConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OutboundTrafficPolicyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutboundTrafficPolicyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PilotConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoscaleEnabled {
		dAtA[i] = 0x10
		i++
		if m.AutoscaleEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoscaleMin != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMin))
	}
	if m.AutoscaleMax != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.AutoscaleMax))
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.Sidecar {
		dAtA[i] = 0x38
		i++
		if m.Sidecar {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TraceSampling != 0 {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TraceSampling))))
		i += 8
	}
	if m.Resources != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Resources.Size()))
		n44, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.ConfigNamespace) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ConfigNamespace)))
		i += copy(dAtA[i:], m.ConfigNamespace)
	}
	if m.Cpu != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Cpu.Size()))
		n45, err := m.Cpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.KeepaliveMaxServerConnectionAge != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.KeepaliveMaxServerConnectionAge.Size()))
		n46, err := m.KeepaliveMaxServerConnectionAge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.DeploymentLabels) > 0 {
		for k, _ := range m.DeploymentLabels {
			dAtA[i] = 0x6a
			i++
			v := m.DeploymentLabels[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.ConfigMap {
		dAtA[i] = 0x70
		i++
		if m.ConfigMap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ingress != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Ingress.Size()))
		n47, err := m.Ingress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.UseMCP {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.UseMCP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Policy != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Policy.Size()))
		n48, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.Telemetry != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Telemetry.Size()))
		n49, err := m.Telemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PilotIngressConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotIngressConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IngressService) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IngressService)))
		i += copy(dAtA[i:], m.IngressService)
	}
	if len(m.IngressClass) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IngressClass)))
		i += copy(dAtA[i:], m.IngressClass)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PilotPolicyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotPolicyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PilotTelemetryConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotTelemetryConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PortsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortsConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Port))
	}
	if m.NodePort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.NodePort))
	}
	if m.TargetPort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.TargetPort))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PrometheusConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrometheusConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CreatePrometheusResource {
		dAtA[i] = 0x8
		i++
		if m.CreatePrometheusResource {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Enabled {
		dAtA[i] = 0x10
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if len(m.Hub) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Hub)))
		i += copy(dAtA[i:], m.Hub)
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if len(m.Retention) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Retention)))
		i += copy(dAtA[i:], m.Retention)
	}
	if m.ScrapeInterval != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ScrapeInterval.Size()))
		n50, err := m.ScrapeInterval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if len(m.ContextPath) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ContextPath)))
		i += copy(dAtA[i:], m.ContextPath)
	}
	if m.Ingress != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Ingress.Size()))
		n51, err := m.Ingress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.Service != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Service.Size()))
		n52, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.Security != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Security.Size()))
		n53, err := m.Security.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PrometheusMixerAdapterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrometheusMixerAdapterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MetricsExpiryDuration != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.MetricsExpiryDuration.Size()))
		n54, err := m.MetricsExpiryDuration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PrometheusSecurityConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrometheusSecurityConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PrometheusServiceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrometheusServiceConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodePort != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.NodePort.Size()))
		n55, err := m.NodePort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PrometheusServiceNodePortConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrometheusServiceNodePortConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccessLogFile) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.AccessLogFile)))
		i += copy(dAtA[i:], m.AccessLogFile)
	}
	if len(m.AccessLogFormat) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.AccessLogFormat)))
		i += copy(dAtA[i:], m.AccessLogFormat)
	}
	if len(m.ClusterDomain) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ClusterDomain)))
		i += copy(dAtA[i:], m.ClusterDomain)
	}
	if len(m.ComponentLogLevel) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ComponentLogLevel)))
		i += copy(dAtA[i:], m.ComponentLogLevel)
	}
	if m.Concurrency != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Concurrency))
	}
	if m.DnsRefreshRate != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.DnsRefreshRate.Size()))
		n56, err := m.DnsRefreshRate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.EnableCoreDump {
		dAtA[i] = 0x48
		i++
		if m.EnableCoreDump {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnvoyMetricsService != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.EnvoyMetricsService.Size()))
		n57, err := m.EnvoyMetricsService.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.EnvoyStatsd != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.EnvoyStatsd.Size()))
		n58, err := m.EnvoyStatsd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if len(m.ExcludeInboundPorts) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ExcludeInboundPorts)))
		i += copy(dAtA[i:], m.ExcludeInboundPorts)
	}
	if len(m.ExcludeIPRanges) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.ExcludeIPRanges)))
		i += copy(dAtA[i:], m.ExcludeIPRanges)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.IncludeInboundPorts) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IncludeInboundPorts)))
		i += copy(dAtA[i:], m.IncludeInboundPorts)
	}
	if len(m.IncludeIPRanges) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.IncludeIPRanges)))
		i += copy(dAtA[i:], m.IncludeIPRanges)
	}
	if len(m.KubevirtInterfaces) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.KubevirtInterfaces)))
		i += copy(dAtA[i:], m.KubevirtInterfaces)
	}
	if len(m.LogLevel) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.LogLevel)))
		i += copy(dAtA[i:], m.LogLevel)
	}
	if m.Privileged {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReadinessInitialDelaySeconds != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReadinessInitialDelaySeconds))
	}
	if m.ReadinessPeriodSeconds != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReadinessPeriodSeconds))
	}
	if m.ReadinessFailureThreshold != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReadinessFailureThreshold))
	}
	if m.StatusPort != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.StatusPort))
	}
	if m.Resources != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Resources.Size()))
		n59, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyInitConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyInitConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Image) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourcesRequestsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcesRequestsConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cpu) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Cpu)))
		i += copy(dAtA[i:], m.Cpu)
	}
	if len(m.Memory) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Memory)))
		i += copy(dAtA[i:], m.Memory)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SDSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SDSConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.UdsPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.UdsPath)))
		i += copy(dAtA[i:], m.UdsPath)
	}
	if m.UseNormalJwt {
		dAtA[i] = 0x18
		i++
		if m.UseNormalJwt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseTrustworthyJwt {
		dAtA[i] = 0x20
		i++
		if m.UseTrustworthyJwt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SecretVolume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretVolume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MountPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.MountPath)))
		i += copy(dAtA[i:], m.MountPath)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.SecretName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.SecretName)))
		i += copy(dAtA[i:], m.SecretName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SecurityConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.SelfSigned {
		dAtA[i] = 0x20
		i++
		if m.SelfSigned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TrustDomain) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.TrustDomain)))
		i += copy(dAtA[i:], m.TrustDomain)
	}
	if len(m.DnsCerts) > 0 {
		for k, _ := range m.DnsCerts {
			dAtA[i] = 0x32
			i++
			v := m.DnsCerts[k]
			mapSize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			i = encodeVarintValuesTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintValuesTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.CreateMeshPolicy {
		dAtA[i] = 0x38
		i++
		if m.CreateMeshPolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServiceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExternalPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ExternalPort))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SidecarInjectorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarInjectorConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableNamespacesByDefault {
		dAtA[i] = 0x10
		i++
		if m.EnableNamespacesByDefault {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if m.RewriteAppHTTPProbe {
		dAtA[i] = 0x28
		i++
		if m.RewriteAppHTTPProbe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SelfSigned {
		dAtA[i] = 0x30
		i++
		if m.SelfSigned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StdioMixerAdapterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StdioMixerAdapterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OutputAsJson {
		dAtA[i] = 0x10
		i++
		if m.OutputAsJson {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TracerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracerConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Datadog != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Datadog.Size()))
		n60, err := m.Datadog.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.Lightstep != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Lightstep.Size()))
		n61, err := m.Lightstep.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.Zipkin != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Zipkin.Size()))
		n62, err := m.Zipkin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TracerDatadogConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracerDatadogConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TracerLightStepConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracerLightStepConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.AccessToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.AccessToken)))
		i += copy(dAtA[i:], m.AccessToken)
	}
	if len(m.CacertPath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.CacertPath)))
		i += copy(dAtA[i:], m.CacertPath)
	}
	if m.Secure {
		dAtA[i] = 0x20
		i++
		if m.Secure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TracerZipkinConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracerZipkinConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TracingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ingress != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Ingress.Size()))
		n63, err := m.Ingress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.Jaeger != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Jaeger.Size()))
		n64, err := m.Jaeger.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if len(m.Provider) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.Service != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Service.Size()))
		n65, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.Zipkin != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Zipkin.Size()))
		n66, err := m.Zipkin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TracingIngressConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingIngressConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TracingJaegerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingJaegerConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hub) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Hub)))
		i += copy(dAtA[i:], m.Hub)
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if m.Memory != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Memory.Size()))
		n67, err := m.Memory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TracingJaegerMemoryConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingJaegerMemoryConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxTraces != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.MaxTraces))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TracingZipkinConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingZipkinConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hub) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Hub)))
		i += copy(dAtA[i:], m.Hub)
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if m.ProbeStartupDelay != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.ProbeStartupDelay))
	}
	if m.QueryPort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.QueryPort))
	}
	if m.Resources != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Resources.Size()))
		n68, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if len(m.JavaOptsHeap) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.JavaOptsHeap)))
		i += copy(dAtA[i:], m.JavaOptsHeap)
	}
	if m.MaxSpans != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.MaxSpans))
	}
	if m.Node != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Node.Size()))
		n69, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TracingZipkinNodeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingZipkinNodeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cpus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Cpus))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Values) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Values) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Certmanager != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Certmanager.Size()))
		n70, err := m.Certmanager.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.IstioCni != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.IstioCni.Size()))
		n71, err := m.IstioCni.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.Istiocoredns != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Istiocoredns.Size()))
		n72, err := m.Istiocoredns.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.Galley != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Galley.Size()))
		n73, err := m.Galley.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if m.Gateways != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Gateways.Size()))
		n74, err := m.Gateways.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.Global != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Global.Size()))
		n75, err := m.Global.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.Mixer != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Mixer.Size()))
		n76, err := m.Mixer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if m.Nodeagent != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Nodeagent.Size()))
		n77, err := m.Nodeagent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if m.Pilot != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Pilot.Size()))
		n78, err := m.Pilot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	if m.Prometheus != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Prometheus.Size()))
		n79, err := m.Prometheus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.Security != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Security.Size()))
		n80, err := m.Security.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.SidecarInjectorWebhook != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.SidecarInjectorWebhook.Size()))
		n81, err := m.SidecarInjectorWebhook.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.Tracing != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(m.Tracing.Size()))
		n82, err := m.Tracing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ZeroVPNConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroVPNConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Suffix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValuesTypes(dAtA, i, uint64(len(m.Suffix)))
		i += copy(dAtA[i:], m.Suffix)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintValuesTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AddonIngressConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArchConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amd64 != 0 {
		n += 1 + sovValuesTypes(uint64(m.Amd64))
	}
	if m.Ppc64Le != 0 {
		n += 1 + sovValuesTypes(uint64(m.Ppc64Le))
	}
	if m.S390X != 0 {
		n += 1 + sovValuesTypes(uint64(m.S390X))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNIConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CPUTargetUtilizationConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetAverageUtilization != 0 {
		n += 1 + sovValuesTypes(uint64(m.TargetAverageUtilization))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertManagerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Hub)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CoreDNSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CoreDNSImage)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.CoreDNSPluginImage)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DefaultPodDisruptionBudgetConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DefaultResourcesConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Requests != nil {
		l = m.Requests.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoscaleEnabled {
		n += 2
	}
	if m.AutoscaleMax != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMin))
	}
	l = len(m.ConnectTimeout)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.DrainDuration != nil {
		l = m.DrainDuration.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if m.Labels != nil {
		l = m.Labels.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.SecretVolumes) > 0 {
		for _, e := range m.SecretVolumes {
			l = e.Size()
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.Zvpn != nil {
		l = m.Zvpn.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyMetricsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovValuesTypes(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GalleyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.Mesh) > 0 {
		for k, v := range m.Mesh {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewayLabelsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.App)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Istio)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewaysConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IstioEgressgateway != nil {
		l = m.IstioEgressgateway.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.IstioIlbgateway != nil {
		l = m.IstioIlbgateway.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.IstioIngressgateway != nil {
		l = m.IstioIngressgateway.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobalConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfigNamespace)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ConfigValidation {
		n += 2
	}
	if m.ControlPlaneSecurityEnabled {
		n += 2
	}
	if m.DefaultPodDisruptionBudget != nil {
		l = m.DefaultPodDisruptionBudget.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.DisablePolicyChecks {
		n += 2
	}
	if m.DefaultResources != nil {
		l = m.DefaultResources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.EnableHelmTest {
		n += 2
	}
	if m.EnableTracing {
		n += 2
	}
	l = len(m.Hub)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.IstioNamespace)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.K8SIngress != nil {
		l = m.K8SIngress.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Logging != nil {
		l = m.Logging.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.MeshExpansion != nil {
		l = m.MeshExpansion.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.MonitoringPort != 0 {
		n += 1 + sovValuesTypes(uint64(m.MonitoringPort))
	}
	if m.Mtls != nil {
		l = m.Mtls.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.MultiCluster != nil {
		l = m.MultiCluster.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.OneNamespace {
		n += 3
	}
	if m.OutboundTrafficPolicy != nil {
		l = m.OutboundTrafficPolicy.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.PolicyCheckFailOpen {
		n += 3
	}
	l = len(m.PolicyNamespace)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.PriorityClassName)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.ProxyInit != nil {
		l = m.ProxyInit.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Sds != nil {
		l = m.Sds.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.TelemetryNamespace)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Tracer != nil {
		l = m.Tracer.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.TrustDomain)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.UseMCP {
		n += 3
	}
	if m.Arch != nil {
		l = m.Arch.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.DefaultNodeSelector) > 0 {
		for k, v := range m.DefaultNodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if len(m.LocalityLbSetting) > 0 {
		for k, v := range m.LocalityLbSetting {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if len(m.MeshNetworks) > 0 {
		for k, v := range m.MeshNetworks {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobalLoggingConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ILBGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoscaleEnabled {
		n += 2
	}
	if m.AutoscaleMax != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMin))
	}
	if m.Enabled {
		n += 2
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.LoadBalancerIP)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.SecretVolumes) > 0 {
		for _, e := range m.SecretVolumes {
			l = e.Size()
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoscaleEnabled {
		n += 2
	}
	if m.AutoscaleMax != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMin))
	}
	l = len(m.ConnectTimeout)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.CustomService {
		n += 2
	}
	l = len(m.Debug)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.DrainDuration != nil {
		l = m.DrainDuration.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if len(m.ExternalIPs) > 0 {
		for _, s := range m.ExternalIPs {
			l = len(s)
			n += 1 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.K8SIngress {
		n += 2
	}
	if m.K8SIngressHttps {
		n += 2
	}
	if m.Labels != nil {
		l = m.Labels.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.LoadBalancerIP)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			l = len(s)
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.MeshExpansionPorts) > 0 {
		for _, e := range m.MeshExpansionPorts {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.ReplicaCount != 0 {
		n += 2 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	if m.Sds != nil {
		l = m.Sds.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if len(m.SecretVolumes) > 0 {
		for _, e := range m.SecretVolumes {
			l = e.Size()
			n += 2 + l + sovValuesTypes(uint64(l))
		}
	}
	if m.Zvpn != nil {
		l = m.Zvpn.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressGatewaySdsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressGatewayZvpnConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Suffix)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesEnvMixerAdapterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesIngressConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.EnableHttps {
		n += 2
	}
	l = len(m.GatewayName)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadSheddingConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LatencyThreshold)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MTLSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MeshExpansionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.UseILB {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MixerAdaptersConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kubernetesenv != nil {
		l = m.Kubernetesenv.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Prometheus != nil {
		l = m.Prometheus.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Stdio != nil {
		l = m.Stdio.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.UseAdapterCRDs {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MixerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Adapters != nil {
		l = m.Adapters.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Telemetry != nil {
		l = m.Telemetry.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MixerPolicyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoscaleEnabled {
		n += 2
	}
	if m.AutoscaleMax != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMin))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MixerTelemetryConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Adapters != nil {
		l = m.Adapters.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.AutoscaleEnabled {
		n += 2
	}
	if m.AutoscaleMax != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMax))
	}
	if m.AutoscaleMin != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMin))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Loadshedding != nil {
		l = m.Loadshedding.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.SessionAffinityEnabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiClusterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeAgentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OutboundTrafficPolicyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.AutoscaleEnabled {
		n += 2
	}
	if m.AutoscaleMin != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMin))
	}
	if m.AutoscaleMax != 0 {
		n += 1 + sovValuesTypes(uint64(m.AutoscaleMax))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Sidecar {
		n += 2
	}
	if m.TraceSampling != 0 {
		n += 9
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ConfigNamespace)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.KeepaliveMaxServerConnectionAge != nil {
		l = m.KeepaliveMaxServerConnectionAge.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.DeploymentLabels) > 0 {
		for k, v := range m.DeploymentLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if m.ConfigMap {
		n += 2
	}
	if m.Ingress != nil {
		l = m.Ingress.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.UseMCP {
		n += 3
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Telemetry != nil {
		l = m.Telemetry.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotIngressConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IngressService)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.IngressClass)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotPolicyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotTelemetryConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PortsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovValuesTypes(uint64(m.Port))
	}
	if m.NodePort != 0 {
		n += 1 + sovValuesTypes(uint64(m.NodePort))
	}
	if m.TargetPort != 0 {
		n += 1 + sovValuesTypes(uint64(m.TargetPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrometheusConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreatePrometheusResource {
		n += 2
	}
	if m.Enabled {
		n += 2
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	l = len(m.Hub)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Retention)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ScrapeInterval != nil {
		l = m.ScrapeInterval.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ContextPath)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Ingress != nil {
		l = m.Ingress.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrometheusMixerAdapterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.MetricsExpiryDuration != nil {
		l = m.MetricsExpiryDuration.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrometheusSecurityConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrometheusServiceConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodePort != nil {
		l = m.NodePort.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrometheusServiceNodePortConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Port != 0 {
		n += 1 + sovValuesTypes(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessLogFile)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.AccessLogFormat)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ClusterDomain)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ComponentLogLevel)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Concurrency != 0 {
		n += 1 + sovValuesTypes(uint64(m.Concurrency))
	}
	if m.DnsRefreshRate != nil {
		l = m.DnsRefreshRate.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.EnableCoreDump {
		n += 2
	}
	if m.EnvoyMetricsService != nil {
		l = m.EnvoyMetricsService.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.EnvoyStatsd != nil {
		l = m.EnvoyStatsd.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ExcludeInboundPorts)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.ExcludeIPRanges)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.IncludeInboundPorts)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.IncludeIPRanges)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.KubevirtInterfaces)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.LogLevel)
	if l > 0 {
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.Privileged {
		n += 3
	}
	if m.ReadinessInitialDelaySeconds != 0 {
		n += 2 + sovValuesTypes(uint64(m.ReadinessInitialDelaySeconds))
	}
	if m.ReadinessPeriodSeconds != 0 {
		n += 2 + sovValuesTypes(uint64(m.ReadinessPeriodSeconds))
	}
	if m.ReadinessFailureThreshold != 0 {
		n += 2 + sovValuesTypes(uint64(m.ReadinessFailureThreshold))
	}
	if m.StatusPort != 0 {
		n += 2 + sovValuesTypes(uint64(m.StatusPort))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyInitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourcesRequestsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cpu)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SDSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.UdsPath)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.UseNormalJwt {
		n += 2
	}
	if m.UseTrustworthyJwt {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecretVolume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.SecretName)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.SelfSigned {
		n += 2
	}
	l = len(m.TrustDomain)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if len(m.DnsCerts) > 0 {
		for k, v := range m.DnsCerts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValuesTypes(uint64(len(k))) + 1 + len(v) + sovValuesTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovValuesTypes(uint64(mapEntrySize))
		}
	}
	if m.CreateMeshPolicy {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalPort != 0 {
		n += 1 + sovValuesTypes(uint64(m.ExternalPort))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SidecarInjectorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.EnableNamespacesByDefault {
		n += 2
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovValuesTypes(uint64(m.ReplicaCount))
	}
	if m.RewriteAppHTTPProbe {
		n += 2
	}
	if m.SelfSigned {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StdioMixerAdapterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.OutputAsJson {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Datadog != nil {
		l = m.Datadog.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Lightstep != nil {
		l = m.Lightstep.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Zipkin != nil {
		l = m.Zipkin.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracerDatadogConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracerLightStepConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.CacertPath)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Secure {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracerZipkinConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracingConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Ingress != nil {
		l = m.Ingress.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Jaeger != nil {
		l = m.Jaeger.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Zipkin != nil {
		l = m.Zipkin.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracingIngressConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracingJaegerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hub)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracingJaegerMemoryConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxTraces != 0 {
		n += 1 + sovValuesTypes(uint64(m.MaxTraces))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracingZipkinConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hub)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.ProbeStartupDelay != 0 {
		n += 1 + sovValuesTypes(uint64(m.ProbeStartupDelay))
	}
	if m.QueryPort != 0 {
		n += 1 + sovValuesTypes(uint64(m.QueryPort))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	l = len(m.JavaOptsHeap)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.MaxSpans != 0 {
		n += 1 + sovValuesTypes(uint64(m.MaxSpans))
	}
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TracingZipkinNodeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cpus != 0 {
		n += 1 + sovValuesTypes(uint64(m.Cpus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Values) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Certmanager != nil {
		l = m.Certmanager.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.IstioCni != nil {
		l = m.IstioCni.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Istiocoredns != nil {
		l = m.Istiocoredns.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Galley != nil {
		l = m.Galley.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Gateways != nil {
		l = m.Gateways.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Mixer != nil {
		l = m.Mixer.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Nodeagent != nil {
		l = m.Nodeagent.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Pilot != nil {
		l = m.Pilot.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Prometheus != nil {
		l = m.Prometheus.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.SidecarInjectorWebhook != nil {
		l = m.SidecarInjectorWebhook.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.Tracing != nil {
		l = m.Tracing.Size()
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroVPNConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Suffix)
	if l > 0 {
		n += 1 + l + sovValuesTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovValuesTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozValuesTypes(x uint64) (n int) {
	return sovValuesTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddonIngressConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddonIngressConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddonIngressConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArchConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArchConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArchConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amd64", wireType)
			}
			m.Amd64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amd64 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ppc64Le", wireType)
			}
			m.Ppc64Le = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ppc64Le |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S390X", wireType)
			}
			m.S390X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S390X |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNIConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNIConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNIConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUTargetUtilizationConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUTargetUtilizationConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUTargetUtilizationConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAverageUtilization", wireType)
			}
			m.TargetAverageUtilization = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetAverageUtilization |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertManagerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertManagerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertManagerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &v1.ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoreDNSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoreDNSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoreDNSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoreDNSImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoreDNSImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoreDNSPluginImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoreDNSPluginImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultPodDisruptionBudgetConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultPodDisruptionBudgetConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultPodDisruptionBudgetConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultResourcesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultResourcesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultResourcesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requests == nil {
				m.Requests = &ResourcesRequestsConfig{}
			}
			if err := m.Requests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoscaleEnabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMax", wireType)
			}
			m.AutoscaleMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMin", wireType)
			}
			m.AutoscaleMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUTargetUtilizationConfig{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrainDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DrainDuration == nil {
				m.DrainDuration = &duration.Duration{}
			}
			if err := m.DrainDuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &GatewayLabelsConfig{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortsConfig{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &v1.ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretVolumes = append(m.SecretVolumes, &SecretVolume{})
			if err := m.SecretVolumes[len(m.SecretVolumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zvpn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zvpn == nil {
				m.Zvpn = &ZeroVPNConfig{}
			}
			if err := m.Zvpn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyMetricsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvoyMetricsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvoyMetricsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GalleyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GalleyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GalleyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mesh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mesh == nil {
				m.Mesh = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mesh[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &v1.ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayLabelsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayLabelsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayLabelsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.App = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Istio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Istio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewaysConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewaysConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewaysConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstioEgressgateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IstioEgressgateway == nil {
				m.IstioEgressgateway = &EgressGatewayConfig{}
			}
			if err := m.IstioEgressgateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstioIlbgateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IstioIlbgateway == nil {
				m.IstioIlbgateway = &ILBGatewayConfig{}
			}
			if err := m.IstioIlbgateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstioIngressgateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IstioIngressgateway == nil {
				m.IstioIngressgateway = &IngressGatewayConfig{}
			}
			if err := m.IstioIngressgateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigValidation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConfigValidation = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPlaneSecurityEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ControlPlaneSecurityEnabled = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultPodDisruptionBudget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultPodDisruptionBudget == nil {
				m.DefaultPodDisruptionBudget = &DefaultPodDisruptionBudgetConfig{}
			}
			if err := m.DefaultPodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePolicyChecks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePolicyChecks = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultResources == nil {
				m.DefaultResources = &DefaultResourcesConfig{}
			}
			if err := m.DefaultResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableHelmTest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableHelmTest = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTracing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTracing = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstioNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IstioNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SIngress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8SIngress == nil {
				m.K8SIngress = &KubernetesIngressConfig{}
			}
			if err := m.K8SIngress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logging", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Logging == nil {
				m.Logging = &GlobalLoggingConfig{}
			}
			if err := m.Logging.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeshExpansion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeshExpansion == nil {
				m.MeshExpansion = &MeshExpansionConfig{}
			}
			if err := m.MeshExpansion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitoringPort", wireType)
			}
			m.MonitoringPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonitoringPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mtls == nil {
				m.Mtls = &MTLSConfig{}
			}
			if err := m.Mtls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultiCluster == nil {
				m.MultiCluster = &MultiClusterConfig{}
			}
			if err := m.MultiCluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneNamespace", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneNamespace = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundTrafficPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutboundTrafficPolicy == nil {
				m.OutboundTrafficPolicy = &OutboundTrafficPolicyConfig{}
			}
			if err := m.OutboundTrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyCheckFailOpen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PolicyCheckFailOpen = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &ProxyConfig{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyInit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyInit == nil {
				m.ProxyInit = &ProxyInitConfig{}
			}
			if err := m.ProxyInit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sds == nil {
				m.Sds = &SDSConfig{}
			}
			if err := m.Sds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelemetryNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TelemetryNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tracer == nil {
				m.Tracer = &TracerConfig{}
			}
			if err := m.Tracer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMCP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMCP = bool(v != 0)
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arch == nil {
				m.Arch = &ArchConfig{}
			}
			if err := m.Arch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultNodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultNodeSelector == nil {
				m.DefaultNodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DefaultNodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityLbSetting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalityLbSetting == nil {
				m.LocalityLbSetting = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LocalityLbSetting[mapkey] = mapvalue
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeshNetworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeshNetworks == nil {
				m.MeshNetworks = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MeshNetworks[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalLoggingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalLoggingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalLoggingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ILBGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ILBGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ILBGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoscaleEnabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMax", wireType)
			}
			m.AutoscaleMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMin", wireType)
			}
			m.AutoscaleMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUTargetUtilizationConfig{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &GatewayLabelsConfig{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortsConfig{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &v1.ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretVolumes = append(m.SecretVolumes, &SecretVolume{})
			if err := m.SecretVolumes[len(m.SecretVolumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoscaleEnabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMax", wireType)
			}
			m.AutoscaleMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMin", wireType)
			}
			m.AutoscaleMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUTargetUtilizationConfig{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomService", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CustomService = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Debug = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrainDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DrainDuration == nil {
				m.DrainDuration = &duration.Duration{}
			}
			if err := m.DrainDuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIPs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIPs = append(m.ExternalIPs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SIngress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.K8SIngress = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SIngressHttps", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.K8SIngressHttps = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &GatewayLabelsConfig{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerSourceRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerSourceRanges = append(m.LoadBalancerSourceRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeshExpansionPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeshExpansionPorts = append(m.MeshExpansionPorts, &PortsConfig{})
			if err := m.MeshExpansionPorts[len(m.MeshExpansionPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortsConfig{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sds == nil {
				m.Sds = &IngressGatewaySdsConfig{}
			}
			if err := m.Sds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretVolumes = append(m.SecretVolumes, &SecretVolume{})
			if err := m.SecretVolumes[len(m.SecretVolumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zvpn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zvpn == nil {
				m.Zvpn = &IngressGatewayZvpnConfig{}
			}
			if err := m.Zvpn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressGatewaySdsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressGatewaySdsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressGatewaySdsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressGatewayZvpnConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressGatewayZvpnConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressGatewayZvpnConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesEnvMixerAdapterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesEnvMixerAdapterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesEnvMixerAdapterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesIngressConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesIngressConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesIngressConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableHttps", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableHttps = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadSheddingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadSheddingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadSheddingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatencyThreshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MTLSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MTLSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MTLSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeshExpansionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeshExpansionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeshExpansionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseILB", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseILB = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MixerAdaptersConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MixerAdaptersConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MixerAdaptersConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kubernetesenv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kubernetesenv == nil {
				m.Kubernetesenv = &KubernetesEnvMixerAdapterConfig{}
			}
			if err := m.Kubernetesenv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prometheus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prometheus == nil {
				m.Prometheus = &PrometheusMixerAdapterConfig{}
			}
			if err := m.Prometheus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stdio == nil {
				m.Stdio = &StdioMixerAdapterConfig{}
			}
			if err := m.Stdio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseAdapterCRDs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseAdapterCRDs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MixerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MixerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MixerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adapters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Adapters == nil {
				m.Adapters = &MixerAdaptersConfig{}
			}
			if err := m.Adapters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &MixerPolicyConfig{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Telemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Telemetry == nil {
				m.Telemetry = &MixerTelemetryConfig{}
			}
			if err := m.Telemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MixerPolicyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MixerPolicyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MixerPolicyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoscaleEnabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMax", wireType)
			}
			m.AutoscaleMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMin", wireType)
			}
			m.AutoscaleMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUTargetUtilizationConfig{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MixerTelemetryConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MixerTelemetryConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MixerTelemetryConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adapters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Adapters == nil {
				m.Adapters = &MixerAdaptersConfig{}
			}
			if err := m.Adapters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoscaleEnabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMax", wireType)
			}
			m.AutoscaleMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMin", wireType)
			}
			m.AutoscaleMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUTargetUtilizationConfig{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loadshedding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Loadshedding == nil {
				m.Loadshedding = &LoadSheddingConfig{}
			}
			if err := m.Loadshedding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &v1.ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAffinityEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SessionAffinityEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiClusterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiClusterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiClusterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeAgentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAgentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAgentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutboundTrafficPolicyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutboundTrafficPolicyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutboundTrafficPolicyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoscaleEnabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMin", wireType)
			}
			m.AutoscaleMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscaleMax", wireType)
			}
			m.AutoscaleMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoscaleMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sidecar", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sidecar = bool(v != 0)
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceSampling", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TraceSampling = float64(math.Float64frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &v1.ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUTargetUtilizationConfig{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepaliveMaxServerConnectionAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeepaliveMaxServerConnectionAge == nil {
				m.KeepaliveMaxServerConnectionAge = &duration.Duration{}
			}
			if err := m.KeepaliveMaxServerConnectionAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentLabels == nil {
				m.DeploymentLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DeploymentLabels[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConfigMap = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ingress == nil {
				m.Ingress = &PilotIngressConfig{}
			}
			if err := m.Ingress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMCP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMCP = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &PilotPolicyConfig{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Telemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Telemetry == nil {
				m.Telemetry = &PilotTelemetryConfig{}
			}
			if err := m.Telemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotIngressConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotIngressConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotIngressConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotPolicyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotPolicyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotPolicyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotTelemetryConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotTelemetryConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotTelemetryConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePort", wireType)
			}
			m.NodePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodePort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPort", wireType)
			}
			m.TargetPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrometheusConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrometheusConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrometheusConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatePrometheusResource", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreatePrometheusResource = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Retention = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrapeInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScrapeInterval == nil {
				m.ScrapeInterval = &duration.Duration{}
			}
			if err := m.ScrapeInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContextPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ingress == nil {
				m.Ingress = &AddonIngressConfig{}
			}
			if err := m.Ingress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &PrometheusServiceConfig{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &PrometheusSecurityConfig{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrometheusMixerAdapterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrometheusMixerAdapterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrometheusMixerAdapterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsExpiryDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetricsExpiryDuration == nil {
				m.MetricsExpiryDuration = &duration.Duration{}
			}
			if err := m.MetricsExpiryDuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrometheusSecurityConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrometheusSecurityConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrometheusSecurityConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrometheusServiceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrometheusServiceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrometheusServiceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodePort == nil {
				m.NodePort = &PrometheusServiceNodePortConfig{}
			}
			if err := m.NodePort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrometheusServiceNodePortConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrometheusServiceNodePortConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrometheusServiceNodePortConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLogFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessLogFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLogFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessLogFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComponentLogLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComponentLogLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			m.Concurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Concurrency |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsRefreshRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DnsRefreshRate == nil {
				m.DnsRefreshRate = &duration.Duration{}
			}
			if err := m.DnsRefreshRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCoreDump", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableCoreDump = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvoyMetricsService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvoyMetricsService == nil {
				m.EnvoyMetricsService = &EnvoyMetricsConfig{}
			}
			if err := m.EnvoyMetricsService.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvoyStatsd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvoyStatsd == nil {
				m.EnvoyStatsd = &EnvoyMetricsConfig{}
			}
			if err := m.EnvoyStatsd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeInboundPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeInboundPorts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeIPRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeIPRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeInboundPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncludeInboundPorts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeIPRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncludeIPRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubevirtInterfaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubevirtInterfaces = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessInitialDelaySeconds", wireType)
			}
			m.ReadinessInitialDelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadinessInitialDelaySeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessPeriodSeconds", wireType)
			}
			m.ReadinessPeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadinessPeriodSeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessFailureThreshold", wireType)
			}
			m.ReadinessFailureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadinessFailureThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusPort", wireType)
			}
			m.StatusPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &v1.ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyInitConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyInitConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyInitConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcesRequestsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcesRequestsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcesRequestsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SDSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SDSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SDSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UdsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseNormalJwt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseNormalJwt = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTrustworthyJwt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseTrustworthyJwt = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretVolume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfSigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SelfSigned = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsCerts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DnsCerts == nil {
				m.DnsCerts = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValuesTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValuesTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValuesTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DnsCerts[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateMeshPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateMeshPolicy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalPort", wireType)
			}
			m.ExternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SidecarInjectorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SidecarInjectorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SidecarInjectorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableNamespacesByDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableNamespacesByDefault = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewriteAppHTTPProbe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RewriteAppHTTPProbe = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfSigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SelfSigned = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StdioMixerAdapterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StdioMixerAdapterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StdioMixerAdapterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputAsJson", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputAsJson = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datadog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datadog == nil {
				m.Datadog = &TracerDatadogConfig{}
			}
			if err := m.Datadog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lightstep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lightstep == nil {
				m.Lightstep = &TracerLightStepConfig{}
			}
			if err := m.Lightstep.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zipkin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zipkin == nil {
				m.Zipkin = &TracerZipkinConfig{}
			}
			if err := m.Zipkin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracerDatadogConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracerDatadogConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracerDatadogConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracerLightStepConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracerLightStepConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracerLightStepConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacertPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacertPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secure = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracerZipkinConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracerZipkinConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracerZipkinConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ingress == nil {
				m.Ingress = &TracingIngressConfig{}
			}
			if err := m.Ingress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jaeger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Jaeger == nil {
				m.Jaeger = &TracingJaegerConfig{}
			}
			if err := m.Jaeger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &ServiceConfig{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zipkin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zipkin == nil {
				m.Zipkin = &TracingZipkinConfig{}
			}
			if err := m.Zipkin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingIngressConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingIngressConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingIngressConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingJaegerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingJaegerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingJaegerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &TracingJaegerMemoryConfig{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingJaegerMemoryConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingJaegerMemoryConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingJaegerMemoryConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTraces", wireType)
			}
			m.MaxTraces = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTraces |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingZipkinConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingZipkinConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingZipkinConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeStartupDelay", wireType)
			}
			m.ProbeStartupDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProbeStartupDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryPort", wireType)
			}
			m.QueryPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &v1.ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaOptsHeap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JavaOptsHeap = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSpans", wireType)
			}
			m.MaxSpans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSpans |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &TracingZipkinNodeConfig{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingZipkinNodeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingZipkinNodeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingZipkinNodeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			m.Cpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Values) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Values: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Values: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certmanager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Certmanager == nil {
				m.Certmanager = &CertManagerConfig{}
			}
			if err := m.Certmanager.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IstioCni", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IstioCni == nil {
				m.IstioCni = &CNIConfig{}
			}
			if err := m.IstioCni.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Istiocoredns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Istiocoredns == nil {
				m.Istiocoredns = &CoreDNSConfig{}
			}
			if err := m.Istiocoredns.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Galley", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Galley == nil {
				m.Galley = &GalleyConfig{}
			}
			if err := m.Galley.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateways == nil {
				m.Gateways = &GatewaysConfig{}
			}
			if err := m.Gateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Global == nil {
				m.Global = &GlobalConfig{}
			}
			if err := m.Global.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mixer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mixer == nil {
				m.Mixer = &MixerConfig{}
			}
			if err := m.Mixer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodeagent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodeagent == nil {
				m.Nodeagent = &NodeAgentConfig{}
			}
			if err := m.Nodeagent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pilot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pilot == nil {
				m.Pilot = &PilotConfig{}
			}
			if err := m.Pilot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prometheus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prometheus == nil {
				m.Prometheus = &PrometheusConfig{}
			}
			if err := m.Prometheus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &SecurityConfig{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarInjectorWebhook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarInjectorWebhook == nil {
				m.SidecarInjectorWebhook = &SidecarInjectorConfig{}
			}
			if err := m.SidecarInjectorWebhook.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tracing == nil {
				m.Tracing = &TracingConfig{}
			}
			if err := m.Tracing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroVPNConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroVPNConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroVPNConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValuesTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValuesTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValuesTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipValuesTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowValuesTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowValuesTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthValuesTypes
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthValuesTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowValuesTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipValuesTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthValuesTypes
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthValuesTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowValuesTypes   = fmt.Errorf("proto: integer overflow")
)
